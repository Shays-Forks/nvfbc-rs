/* automatically generated by rust-bindgen 0.60.1 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const NVFBC_VERSION_MAJOR: u32 = 1;
pub const NVFBC_VERSION_MINOR: u32 = 8;
pub const NVFBC_ERR_STR_LEN: u32 = 512;
pub const NVFBC_OUTPUT_MAX: u32 = 5;
pub const NVFBC_OUTPUT_NAME_LEN: u32 = 128;
pub const NVFBC_TOGL_TEXTURES_MAX: u32 = 2;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
	pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
	assert_eq!(
		::std::mem::size_of::<__fsid_t>(),
		8usize,
		concat!("Size of: ", stringify!(__fsid_t))
	);
	assert_eq!(
		::std::mem::align_of::<__fsid_t>(),
		4usize,
		concat!("Alignment of ", stringify!(__fsid_t))
	);
	fn test_field___val() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<__fsid_t>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
			},
			0usize,
			concat!("Offset of field: ", stringify!(__fsid_t), "::", stringify!(__val))
		);
	}
	test_field___val();
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " This indicates that the API call returned with no errors."]
pub const _NVFBCSTATUS_NVFBC_SUCCESS: _NVFBCSTATUS = 0;
#[doc = " This indicates that the API version between the client and the library"]
#[doc = " is not compatible."]
pub const _NVFBCSTATUS_NVFBC_ERR_API_VERSION: _NVFBCSTATUS = 1;
#[doc = " An internal error occurred."]
pub const _NVFBCSTATUS_NVFBC_ERR_INTERNAL: _NVFBCSTATUS = 2;
#[doc = " This indicates that one or more of the parameter passed to the API call"]
#[doc = " is invalid."]
pub const _NVFBCSTATUS_NVFBC_ERR_INVALID_PARAM: _NVFBCSTATUS = 3;
#[doc = " This indicates that one or more of the pointers passed to the API call"]
#[doc = " is invalid."]
pub const _NVFBCSTATUS_NVFBC_ERR_INVALID_PTR: _NVFBCSTATUS = 4;
#[doc = " This indicates that the handle passed to the API call to identify the"]
#[doc = " client is invalid."]
pub const _NVFBCSTATUS_NVFBC_ERR_INVALID_HANDLE: _NVFBCSTATUS = 5;
#[doc = " This indicates that the maximum number of threaded clients of the same"]
#[doc = " process has been reached.  The limit is 10 threads per process."]
#[doc = " There is no limit on the number of process."]
pub const _NVFBCSTATUS_NVFBC_ERR_MAX_CLIENTS: _NVFBCSTATUS = 6;
#[doc = " This indicates that the requested feature is not currently supported"]
#[doc = " by the library."]
pub const _NVFBCSTATUS_NVFBC_ERR_UNSUPPORTED: _NVFBCSTATUS = 7;
#[doc = " This indicates that the API call failed because it was unable to allocate"]
#[doc = " enough memory to perform the requested operation."]
pub const _NVFBCSTATUS_NVFBC_ERR_OUT_OF_MEMORY: _NVFBCSTATUS = 8;
#[doc = " This indicates that the API call was not expected.  This happens when"]
#[doc = " API calls are performed in a wrong order, such as trying to capture"]
#[doc = " a frame prior to creating a new capture session; or trying to set up"]
#[doc = " a capture to video memory although a capture session to system memory"]
#[doc = " was created."]
pub const _NVFBCSTATUS_NVFBC_ERR_BAD_REQUEST: _NVFBCSTATUS = 9;
#[doc = " This indicates an X error, most likely meaning that the X server has"]
#[doc = " been terminated.  When this error is returned, the only resort is to"]
#[doc = " create another FBC handle using NvFBCCreateHandle()."]
#[doc = ""]
#[doc = " The previous handle should still be freed with NvFBCDestroyHandle(), but"]
#[doc = " it might leak resources, in particular X, GLX, and GL resources since"]
#[doc = " it is no longer possible to communicate with an X server to free them"]
#[doc = " through the driver."]
#[doc = ""]
#[doc = " The best course of action to eliminate this potential leak is to close"]
#[doc = " the OpenGL driver, close the forked process running the capture, or"]
#[doc = " restart the application."]
pub const _NVFBCSTATUS_NVFBC_ERR_X: _NVFBCSTATUS = 10;
#[doc = " This indicates a GLX error."]
pub const _NVFBCSTATUS_NVFBC_ERR_GLX: _NVFBCSTATUS = 11;
#[doc = " This indicates an OpenGL error."]
pub const _NVFBCSTATUS_NVFBC_ERR_GL: _NVFBCSTATUS = 12;
#[doc = " This indicates a CUDA error."]
pub const _NVFBCSTATUS_NVFBC_ERR_CUDA: _NVFBCSTATUS = 13;
#[doc = " This indicates a HW encoder error."]
pub const _NVFBCSTATUS_NVFBC_ERR_ENCODER: _NVFBCSTATUS = 14;
#[doc = " This indicates an NvFBC context error."]
pub const _NVFBCSTATUS_NVFBC_ERR_CONTEXT: _NVFBCSTATUS = 15;
#[doc = " This indicates that the application must recreate the capture session."]
#[doc = ""]
#[doc = " This error can be returned if a modeset event occurred while capturing"]
#[doc = " frames, and NVFBC_CREATE_HANDLE_PARAMS::bDisableAutoModesetRecovery"]
#[doc = " was set to NVFBC_TRUE."]
pub const _NVFBCSTATUS_NVFBC_ERR_MUST_RECREATE: _NVFBCSTATUS = 16;
#[doc = " This indicates a Vulkan error."]
pub const _NVFBCSTATUS_NVFBC_ERR_VULKAN: _NVFBCSTATUS = 17;
#[doc = " Defines error codes."]
#[doc = ""]
#[doc = " \\see NvFBCGetLastErrorStr"]
pub type _NVFBCSTATUS = ::std::os::raw::c_uint;
#[doc = " Defines error codes."]
#[doc = ""]
#[doc = " \\see NvFBCGetLastErrorStr"]
pub use self::_NVFBCSTATUS as NVFBCSTATUS;
#[doc = " False value."]
pub const _NVFBC_BOOL_NVFBC_FALSE: _NVFBC_BOOL = 0;
#[doc = " True value."]
pub const _NVFBC_BOOL_NVFBC_TRUE: _NVFBC_BOOL = 1;
#[doc = " Defines boolean values."]
pub type _NVFBC_BOOL = ::std::os::raw::c_uint;
#[doc = " Defines boolean values."]
pub use self::_NVFBC_BOOL as NVFBC_BOOL;
#[doc = " Capture frames to a buffer in system memory."]
pub const _NVFBC_CAPTURE_TYPE_NVFBC_CAPTURE_TO_SYS: _NVFBC_CAPTURE_TYPE = 0;
#[doc = " Capture frames to a CUDA device in video memory."]
#[doc = ""]
#[doc = " Specifying this will dlopen() libcuda.so.1 and fail if not available."]
pub const _NVFBC_CAPTURE_TYPE_NVFBC_CAPTURE_SHARED_CUDA: _NVFBC_CAPTURE_TYPE = 1;
#[doc = " Capture frames to an OpenGL buffer in video memory."]
pub const _NVFBC_CAPTURE_TYPE_NVFBC_CAPTURE_TO_GL: _NVFBC_CAPTURE_TYPE = 3;
#[doc = " Capture type."]
pub type _NVFBC_CAPTURE_TYPE = ::std::os::raw::c_uint;
#[doc = " Capture type."]
pub use self::_NVFBC_CAPTURE_TYPE as NVFBC_CAPTURE_TYPE;
#[doc = " By default, NvFBC tries to track a connected primary output.  If none is"]
#[doc = " found, then it tries to track the first connected output.  If none is"]
#[doc = " found then it tracks the entire X screen."]
#[doc = ""]
#[doc = " If the XRandR extension is not available, this option has the same effect"]
#[doc = " as ::NVFBC_TRACKING_SCREEN."]
#[doc = ""]
#[doc = " This default behavior might be subject to changes in the future."]
pub const NVFBC_TRACKING_TYPE_NVFBC_TRACKING_DEFAULT: NVFBC_TRACKING_TYPE = 0;
#[doc = " Track an RandR output specified by its ID in the appropriate field."]
#[doc = ""]
#[doc = " The list of connected outputs can be queried via NvFBCGetStatus()."]
#[doc = " This list can also be obtained using e.g., xrandr(1)."]
#[doc = ""]
#[doc = " If the XRandR extension is not available, setting this option returns an"]
#[doc = " error."]
pub const NVFBC_TRACKING_TYPE_NVFBC_TRACKING_OUTPUT: NVFBC_TRACKING_TYPE = 1;
#[doc = " Track the entire X screen."]
pub const NVFBC_TRACKING_TYPE_NVFBC_TRACKING_SCREEN: NVFBC_TRACKING_TYPE = 2;
#[doc = " Tracking type."]
#[doc = ""]
#[doc = " NvFBC can track a specific region of the framebuffer to capture."]
#[doc = ""]
#[doc = " An X screen corresponds to the entire framebuffer."]
#[doc = ""]
#[doc = " An RandR CRTC is a component of the GPU that reads pixels from a region of"]
#[doc = " the X screen and sends them through a pipeline to an RandR output."]
#[doc = " A physical monitor can be connected to an RandR output.  Tracking an RandR"]
#[doc = " output captures the region of the X screen that the RandR CRTC is sending to"]
#[doc = " the RandR output."]
pub type NVFBC_TRACKING_TYPE = ::std::os::raw::c_uint;
#[doc = " Data will be converted to ARGB8888 byte-order format. 32 bpp."]
pub const _NVFBC_BUFFER_FORMAT_NVFBC_BUFFER_FORMAT_ARGB: _NVFBC_BUFFER_FORMAT = 0;
#[doc = " Data will be converted to RGB888 byte-order format. 24 bpp."]
pub const _NVFBC_BUFFER_FORMAT_NVFBC_BUFFER_FORMAT_RGB: _NVFBC_BUFFER_FORMAT = 1;
#[doc = " Data will be converted to NV12 format using HDTV weights"]
#[doc = " according to ITU-R BT.709.  12 bpp."]
pub const _NVFBC_BUFFER_FORMAT_NVFBC_BUFFER_FORMAT_NV12: _NVFBC_BUFFER_FORMAT = 2;
#[doc = " Data will be converted to YUV 444 planar format using HDTV weights"]
#[doc = " according to ITU-R BT.709.  24 bpp"]
pub const _NVFBC_BUFFER_FORMAT_NVFBC_BUFFER_FORMAT_YUV444P: _NVFBC_BUFFER_FORMAT = 3;
#[doc = " Data will be converted to RGBA8888 byte-order format. 32 bpp."]
pub const _NVFBC_BUFFER_FORMAT_NVFBC_BUFFER_FORMAT_RGBA: _NVFBC_BUFFER_FORMAT = 4;
#[doc = " Native format. No pixel conversion needed."]
#[doc = " BGRA8888 byte-order format. 32 bpp."]
pub const _NVFBC_BUFFER_FORMAT_NVFBC_BUFFER_FORMAT_BGRA: _NVFBC_BUFFER_FORMAT = 5;
#[doc = " Buffer format."]
pub type _NVFBC_BUFFER_FORMAT = ::std::os::raw::c_uint;
#[doc = " Buffer format."]
pub use self::_NVFBC_BUFFER_FORMAT as NVFBC_BUFFER_FORMAT;
#[doc = " Handle used to identify an NvFBC session."]
pub type NVFBC_SESSION_HANDLE = u64;
#[doc = " Box used to describe an area of the tracked region to capture."]
#[doc = ""]
#[doc = " The coordinates are relative to the tracked region."]
#[doc = ""]
#[doc = " E.g., if the size of the X screen is 3520x1200 and the tracked RandR output"]
#[doc = " scans a region of 1600x1200+1920+0, then setting a capture box of"]
#[doc = " 800x600+100+50 effectively captures a region of 800x600+2020+50 relative to"]
#[doc = " the X screen."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVFBC_BOX {
	#[doc = " [in] X offset of the box."]
	pub x: u32,
	#[doc = " [in] Y offset of the box."]
	pub y: u32,
	#[doc = " [in] Width of the box."]
	pub w: u32,
	#[doc = " [in] Height of the box."]
	pub h: u32,
}
#[test]
fn bindgen_test_layout__NVFBC_BOX() {
	assert_eq!(
		::std::mem::size_of::<_NVFBC_BOX>(),
		16usize,
		concat!("Size of: ", stringify!(_NVFBC_BOX))
	);
	assert_eq!(
		::std::mem::align_of::<_NVFBC_BOX>(),
		4usize,
		concat!("Alignment of ", stringify!(_NVFBC_BOX))
	);
	fn test_field_x() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_BOX>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
			},
			0usize,
			concat!("Offset of field: ", stringify!(_NVFBC_BOX), "::", stringify!(x))
		);
	}
	test_field_x();
	fn test_field_y() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_BOX>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
			},
			4usize,
			concat!("Offset of field: ", stringify!(_NVFBC_BOX), "::", stringify!(y))
		);
	}
	test_field_y();
	fn test_field_w() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_BOX>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
			},
			8usize,
			concat!("Offset of field: ", stringify!(_NVFBC_BOX), "::", stringify!(w))
		);
	}
	test_field_w();
	fn test_field_h() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_BOX>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize
			},
			12usize,
			concat!("Offset of field: ", stringify!(_NVFBC_BOX), "::", stringify!(h))
		);
	}
	test_field_h();
}
#[doc = " Box used to describe an area of the tracked region to capture."]
#[doc = ""]
#[doc = " The coordinates are relative to the tracked region."]
#[doc = ""]
#[doc = " E.g., if the size of the X screen is 3520x1200 and the tracked RandR output"]
#[doc = " scans a region of 1600x1200+1920+0, then setting a capture box of"]
#[doc = " 800x600+100+50 effectively captures a region of 800x600+2020+50 relative to"]
#[doc = " the X screen."]
pub type NVFBC_BOX = _NVFBC_BOX;
#[doc = " Size used to describe the size of a frame."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVFBC_SIZE {
	#[doc = " [in] Width."]
	pub w: u32,
	#[doc = " [in] Height."]
	pub h: u32,
}
#[test]
fn bindgen_test_layout__NVFBC_SIZE() {
	assert_eq!(
		::std::mem::size_of::<_NVFBC_SIZE>(),
		8usize,
		concat!("Size of: ", stringify!(_NVFBC_SIZE))
	);
	assert_eq!(
		::std::mem::align_of::<_NVFBC_SIZE>(),
		4usize,
		concat!("Alignment of ", stringify!(_NVFBC_SIZE))
	);
	fn test_field_w() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_SIZE>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
			},
			0usize,
			concat!("Offset of field: ", stringify!(_NVFBC_SIZE), "::", stringify!(w))
		);
	}
	test_field_w();
	fn test_field_h() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_SIZE>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize
			},
			4usize,
			concat!("Offset of field: ", stringify!(_NVFBC_SIZE), "::", stringify!(h))
		);
	}
	test_field_h();
}
#[doc = " Size used to describe the size of a frame."]
pub type NVFBC_SIZE = _NVFBC_SIZE;
#[doc = " Describes information about a captured frame."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVFBC_FRAME_GRAB_INFO {
	#[doc = " [out] Width of the captured frame."]
	pub dwWidth: u32,
	#[doc = " [out] Height of the captured frame."]
	pub dwHeight: u32,
	#[doc = " [out] Size of the frame in bytes."]
	pub dwByteSize: u32,
	#[doc = " [out] Incremental ID of the current frame."]
	#[doc = ""]
	#[doc = " This can be used to identify a frame."]
	pub dwCurrentFrame: u32,
	#[doc = " [out] Whether the captured frame is a new frame."]
	#[doc = ""]
	#[doc = " When using non blocking calls it is possible to capture a frame"]
	#[doc = " that was already captured before if the display server did not"]
	#[doc = " render a new frame in the meantime.  In that case, this flag"]
	#[doc = " will be set to NVFBC_FALSE."]
	#[doc = ""]
	#[doc = " When using blocking calls each captured frame will have"]
	#[doc = " this flag set to NVFBC_TRUE since the blocking mechanism waits for"]
	#[doc = " the display server to render a new frame."]
	#[doc = ""]
	#[doc = " Note that this flag does not guarantee that the content of"]
	#[doc = " the frame will be different compared to the previous captured frame."]
	#[doc = ""]
	#[doc = " In particular, some compositing managers report the entire"]
	#[doc = " framebuffer as damaged when an application refreshes its content."]
	#[doc = ""]
	#[doc = " Consider a single X screen spanned across physical displays A and B"]
	#[doc = " and an NvFBC application tracking display A.  Depending on the"]
	#[doc = " compositing manager, it is possible that an application refreshing"]
	#[doc = " itself on display B will trigger a frame capture on display A."]
	#[doc = ""]
	#[doc = " Workarounds include:"]
	#[doc = " - Using separate X screens"]
	#[doc = " - Disabling the composite extension"]
	#[doc = " - Using a compositing manager that properly reports what regions"]
	#[doc = "   are damaged"]
	#[doc = " - Using NvFBC's diffmaps to find out if the frame changed"]
	pub bIsNewFrame: NVFBC_BOOL,
	#[doc = " [out] Frame timestamp"]
	#[doc = ""]
	#[doc = " Time in micro seconds when the display server started rendering the"]
	#[doc = " frame."]
	#[doc = ""]
	#[doc = " This does not account for when the frame was captured.  If capturing an"]
	#[doc = " old frame (e.g., bIsNewFrame is NVFBC_FALSE) the reported timestamp"]
	#[doc = " will reflect the time when the old frame was rendered by the display"]
	#[doc = " server."]
	pub ulTimestampUs: u64,
	pub dwMissedFrames: u32,
	pub bRequiredPostProcessing: NVFBC_BOOL,
	pub bDirectCapture: NVFBC_BOOL,
}
#[test]
fn bindgen_test_layout__NVFBC_FRAME_GRAB_INFO() {
	assert_eq!(
		::std::mem::size_of::<_NVFBC_FRAME_GRAB_INFO>(),
		48usize,
		concat!("Size of: ", stringify!(_NVFBC_FRAME_GRAB_INFO))
	);
	assert_eq!(
		::std::mem::align_of::<_NVFBC_FRAME_GRAB_INFO>(),
		8usize,
		concat!("Alignment of ", stringify!(_NVFBC_FRAME_GRAB_INFO))
	);
	fn test_field_dwWidth() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_FRAME_GRAB_INFO>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwWidth) as usize - ptr as usize
			},
			0usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_FRAME_GRAB_INFO),
				"::",
				stringify!(dwWidth)
			)
		);
	}
	test_field_dwWidth();
	fn test_field_dwHeight() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_FRAME_GRAB_INFO>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwHeight) as usize - ptr as usize
			},
			4usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_FRAME_GRAB_INFO),
				"::",
				stringify!(dwHeight)
			)
		);
	}
	test_field_dwHeight();
	fn test_field_dwByteSize() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_FRAME_GRAB_INFO>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwByteSize) as usize - ptr as usize
			},
			8usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_FRAME_GRAB_INFO),
				"::",
				stringify!(dwByteSize)
			)
		);
	}
	test_field_dwByteSize();
	fn test_field_dwCurrentFrame() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_FRAME_GRAB_INFO>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwCurrentFrame) as usize - ptr as usize
			},
			12usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_FRAME_GRAB_INFO),
				"::",
				stringify!(dwCurrentFrame)
			)
		);
	}
	test_field_dwCurrentFrame();
	fn test_field_bIsNewFrame() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_FRAME_GRAB_INFO>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).bIsNewFrame) as usize - ptr as usize
			},
			16usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_FRAME_GRAB_INFO),
				"::",
				stringify!(bIsNewFrame)
			)
		);
	}
	test_field_bIsNewFrame();
	fn test_field_ulTimestampUs() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_FRAME_GRAB_INFO>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).ulTimestampUs) as usize - ptr as usize
			},
			24usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_FRAME_GRAB_INFO),
				"::",
				stringify!(ulTimestampUs)
			)
		);
	}
	test_field_ulTimestampUs();
	fn test_field_dwMissedFrames() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_FRAME_GRAB_INFO>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwMissedFrames) as usize - ptr as usize
			},
			32usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_FRAME_GRAB_INFO),
				"::",
				stringify!(dwMissedFrames)
			)
		);
	}
	test_field_dwMissedFrames();
	fn test_field_bRequiredPostProcessing() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_FRAME_GRAB_INFO>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).bRequiredPostProcessing) as usize - ptr as usize
			},
			36usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_FRAME_GRAB_INFO),
				"::",
				stringify!(bRequiredPostProcessing)
			)
		);
	}
	test_field_bRequiredPostProcessing();
	fn test_field_bDirectCapture() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_FRAME_GRAB_INFO>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).bDirectCapture) as usize - ptr as usize
			},
			40usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_FRAME_GRAB_INFO),
				"::",
				stringify!(bDirectCapture)
			)
		);
	}
	test_field_bDirectCapture();
}
#[doc = " Describes information about a captured frame."]
pub type NVFBC_FRAME_GRAB_INFO = _NVFBC_FRAME_GRAB_INFO;
#[doc = " Defines parameters for the CreateHandle() API call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVFBC_CREATE_HANDLE_PARAMS {
	#[doc = " [in] Must be set to NVFBC_CREATE_HANDLE_PARAMS_VER"]
	pub dwVersion: u32,
	#[doc = " [in] Application specific private information passed to the NvFBC"]
	#[doc = " session."]
	pub privateData: *const ::std::os::raw::c_void,
	#[doc = " [in] Size of the application specific private information passed to the"]
	#[doc = " NvFBC session."]
	pub privateDataSize: u32,
	#[doc = " [in] Whether NvFBC should not create and manage its own graphics context"]
	#[doc = ""]
	#[doc = " NvFBC internally uses OpenGL to perfom graphics operations on the"]
	#[doc = " captured frames.  By default, NvFBC will create and manage (e.g., make"]
	#[doc = " current, detect new threads, etc.) its own OpenGL context."]
	#[doc = ""]
	#[doc = " If set to NVFBC_TRUE, NvFBC will use the application's context.  It will"]
	#[doc = " be the application's responsibility to make sure that a context is"]
	#[doc = " current on the thread calling into the NvFBC API."]
	pub bExternallyManagedContext: NVFBC_BOOL,
	#[doc = " [in] GLX context"]
	#[doc = ""]
	#[doc = " GLX context that NvFBC should use internally to create pixmaps and"]
	#[doc = " make them current when creating a new capture session."]
	#[doc = ""]
	#[doc = " Note: NvFBC expects a context created against a GLX_RGBA_TYPE render"]
	#[doc = " type."]
	pub glxCtx: *mut ::std::os::raw::c_void,
	#[doc = " [in] GLX framebuffer configuration"]
	#[doc = ""]
	#[doc = " Framebuffer configuration that was used to create the GLX context, and"]
	#[doc = " that will be used to create pixmaps internally."]
	#[doc = ""]
	#[doc = " Note: NvFBC expects a configuration having at least the following"]
	#[doc = " attributes:"]
	#[doc = "  GLX_DRAWABLE_TYPE, GLX_PIXMAP_BIT"]
	#[doc = "  GLX_BIND_TO_TEXTURE_RGBA_EXT, 1"]
	#[doc = "  GLX_BIND_TO_TEXTURE_TARGETS_EXT, GLX_TEXTURE_2D_BIT_EXT"]
	pub glxFBConfig: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__NVFBC_CREATE_HANDLE_PARAMS() {
	assert_eq!(
		::std::mem::size_of::<_NVFBC_CREATE_HANDLE_PARAMS>(),
		40usize,
		concat!("Size of: ", stringify!(_NVFBC_CREATE_HANDLE_PARAMS))
	);
	assert_eq!(
		::std::mem::align_of::<_NVFBC_CREATE_HANDLE_PARAMS>(),
		8usize,
		concat!("Alignment of ", stringify!(_NVFBC_CREATE_HANDLE_PARAMS))
	);
	fn test_field_dwVersion() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_CREATE_HANDLE_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwVersion) as usize - ptr as usize
			},
			0usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_CREATE_HANDLE_PARAMS),
				"::",
				stringify!(dwVersion)
			)
		);
	}
	test_field_dwVersion();
	fn test_field_privateData() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_CREATE_HANDLE_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).privateData) as usize - ptr as usize
			},
			8usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_CREATE_HANDLE_PARAMS),
				"::",
				stringify!(privateData)
			)
		);
	}
	test_field_privateData();
	fn test_field_privateDataSize() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_CREATE_HANDLE_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).privateDataSize) as usize - ptr as usize
			},
			16usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_CREATE_HANDLE_PARAMS),
				"::",
				stringify!(privateDataSize)
			)
		);
	}
	test_field_privateDataSize();
	fn test_field_bExternallyManagedContext() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_CREATE_HANDLE_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).bExternallyManagedContext) as usize - ptr as usize
			},
			20usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_CREATE_HANDLE_PARAMS),
				"::",
				stringify!(bExternallyManagedContext)
			)
		);
	}
	test_field_bExternallyManagedContext();
	fn test_field_glxCtx() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_CREATE_HANDLE_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).glxCtx) as usize - ptr as usize
			},
			24usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_CREATE_HANDLE_PARAMS),
				"::",
				stringify!(glxCtx)
			)
		);
	}
	test_field_glxCtx();
	fn test_field_glxFBConfig() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_CREATE_HANDLE_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).glxFBConfig) as usize - ptr as usize
			},
			32usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_CREATE_HANDLE_PARAMS),
				"::",
				stringify!(glxFBConfig)
			)
		);
	}
	test_field_glxFBConfig();
}
#[doc = " Defines parameters for the CreateHandle() API call."]
pub type NVFBC_CREATE_HANDLE_PARAMS = _NVFBC_CREATE_HANDLE_PARAMS;
#[doc = " Defines parameters for the ::NvFBCDestroyHandle() API call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVFBC_DESTROY_HANDLE_PARAMS {
	#[doc = " [in] Must be set to NVFBC_DESTROY_HANDLE_PARAMS_VER"]
	pub dwVersion: u32,
}
#[test]
fn bindgen_test_layout__NVFBC_DESTROY_HANDLE_PARAMS() {
	assert_eq!(
		::std::mem::size_of::<_NVFBC_DESTROY_HANDLE_PARAMS>(),
		4usize,
		concat!("Size of: ", stringify!(_NVFBC_DESTROY_HANDLE_PARAMS))
	);
	assert_eq!(
		::std::mem::align_of::<_NVFBC_DESTROY_HANDLE_PARAMS>(),
		4usize,
		concat!("Alignment of ", stringify!(_NVFBC_DESTROY_HANDLE_PARAMS))
	);
	fn test_field_dwVersion() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_DESTROY_HANDLE_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwVersion) as usize - ptr as usize
			},
			0usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_DESTROY_HANDLE_PARAMS),
				"::",
				stringify!(dwVersion)
			)
		);
	}
	test_field_dwVersion();
}
#[doc = " Defines parameters for the ::NvFBCDestroyHandle() API call."]
pub type NVFBC_DESTROY_HANDLE_PARAMS = _NVFBC_DESTROY_HANDLE_PARAMS;
#[doc = " Describes an RandR output."]
#[doc = ""]
#[doc = " Filling this structure relies on the XRandR extension.  This feature cannot"]
#[doc = " be used if the extension is missing or its version is below the requirements."]
#[doc = ""]
#[doc = " \\see Requirements"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVFBC_OUTPUT {
	#[doc = " Identifier of the RandR output."]
	pub dwId: u32,
	#[doc = " Name of the RandR output, as reported by tools such as xrandr(1)."]
	#[doc = ""]
	#[doc = " Example: \"DVI-I-0\""]
	pub name: [::std::os::raw::c_char; 128usize],
	#[doc = " Region of the X screen tracked by the RandR CRTC driving this RandR"]
	#[doc = " output."]
	pub trackedBox: NVFBC_BOX,
}
#[test]
fn bindgen_test_layout__NVFBC_OUTPUT() {
	assert_eq!(
		::std::mem::size_of::<_NVFBC_OUTPUT>(),
		148usize,
		concat!("Size of: ", stringify!(_NVFBC_OUTPUT))
	);
	assert_eq!(
		::std::mem::align_of::<_NVFBC_OUTPUT>(),
		4usize,
		concat!("Alignment of ", stringify!(_NVFBC_OUTPUT))
	);
	fn test_field_dwId() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_OUTPUT>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwId) as usize - ptr as usize
			},
			0usize,
			concat!("Offset of field: ", stringify!(_NVFBC_OUTPUT), "::", stringify!(dwId))
		);
	}
	test_field_dwId();
	fn test_field_name() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_OUTPUT>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
			},
			4usize,
			concat!("Offset of field: ", stringify!(_NVFBC_OUTPUT), "::", stringify!(name))
		);
	}
	test_field_name();
	fn test_field_trackedBox() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_OUTPUT>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).trackedBox) as usize - ptr as usize
			},
			132usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_OUTPUT),
				"::",
				stringify!(trackedBox)
			)
		);
	}
	test_field_trackedBox();
}
#[doc = " Describes an RandR output."]
#[doc = ""]
#[doc = " Filling this structure relies on the XRandR extension.  This feature cannot"]
#[doc = " be used if the extension is missing or its version is below the requirements."]
#[doc = ""]
#[doc = " \\see Requirements"]
pub type NVFBC_RANDR_OUTPUT_INFO = _NVFBC_OUTPUT;
#[doc = " Defines parameters for the ::NvFBCGetStatus() API call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVFBC_GET_STATUS_PARAMS {
	#[doc = " [in] Must be set to NVFBC_GET_STATUS_PARAMS_VER"]
	pub dwVersion: u32,
	#[doc = " [out] Whether or not framebuffer capture is supported by the graphics"]
	#[doc = " driver."]
	pub bIsCapturePossible: NVFBC_BOOL,
	#[doc = " [out] Whether or not there is already a capture session on this system."]
	pub bCurrentlyCapturing: NVFBC_BOOL,
	#[doc = " [out] Whether or not it is possible to create a capture session on this"]
	#[doc = " system."]
	pub bCanCreateNow: NVFBC_BOOL,
	#[doc = " [out] Size of the X screen (framebuffer)."]
	pub screenSize: NVFBC_SIZE,
	#[doc = " [out] Whether the XRandR extension is available."]
	#[doc = ""]
	#[doc = " If this extension is not available then it is not possible to have"]
	#[doc = " information about RandR outputs."]
	pub bXRandRAvailable: NVFBC_BOOL,
	#[doc = " [out] Array of outputs connected to the X screen."]
	#[doc = ""]
	#[doc = " An application can track a specific output by specifying its ID when"]
	#[doc = " creating a capture session."]
	#[doc = ""]
	#[doc = " Only if XRandR is available."]
	pub outputs: [NVFBC_RANDR_OUTPUT_INFO; 5usize],
	#[doc = " [out] Number of outputs connected to the X screen."]
	#[doc = ""]
	#[doc = " This must be used to parse the array of connected outputs."]
	#[doc = ""]
	#[doc = " Only if XRandR is available."]
	pub dwOutputNum: u32,
	#[doc = " [out] Version of the NvFBC library running on this system."]
	pub dwNvFBCVersion: u32,
	#[doc = " [out] Whether the X server is currently in modeset."]
	#[doc = ""]
	#[doc = " When the X server is in modeset, it must give up all its video"]
	#[doc = " memory allocations. It is not possible to create a capture"]
	#[doc = " session until the modeset is over."]
	#[doc = ""]
	#[doc = " Note that VT-switches are considered modesets."]
	pub bInModeset: NVFBC_BOOL,
}
#[test]
fn bindgen_test_layout__NVFBC_GET_STATUS_PARAMS() {
	assert_eq!(
		::std::mem::size_of::<_NVFBC_GET_STATUS_PARAMS>(),
		780usize,
		concat!("Size of: ", stringify!(_NVFBC_GET_STATUS_PARAMS))
	);
	assert_eq!(
		::std::mem::align_of::<_NVFBC_GET_STATUS_PARAMS>(),
		4usize,
		concat!("Alignment of ", stringify!(_NVFBC_GET_STATUS_PARAMS))
	);
	fn test_field_dwVersion() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_GET_STATUS_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwVersion) as usize - ptr as usize
			},
			0usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_GET_STATUS_PARAMS),
				"::",
				stringify!(dwVersion)
			)
		);
	}
	test_field_dwVersion();
	fn test_field_bIsCapturePossible() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_GET_STATUS_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).bIsCapturePossible) as usize - ptr as usize
			},
			4usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_GET_STATUS_PARAMS),
				"::",
				stringify!(bIsCapturePossible)
			)
		);
	}
	test_field_bIsCapturePossible();
	fn test_field_bCurrentlyCapturing() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_GET_STATUS_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).bCurrentlyCapturing) as usize - ptr as usize
			},
			8usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_GET_STATUS_PARAMS),
				"::",
				stringify!(bCurrentlyCapturing)
			)
		);
	}
	test_field_bCurrentlyCapturing();
	fn test_field_bCanCreateNow() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_GET_STATUS_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).bCanCreateNow) as usize - ptr as usize
			},
			12usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_GET_STATUS_PARAMS),
				"::",
				stringify!(bCanCreateNow)
			)
		);
	}
	test_field_bCanCreateNow();
	fn test_field_screenSize() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_GET_STATUS_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).screenSize) as usize - ptr as usize
			},
			16usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_GET_STATUS_PARAMS),
				"::",
				stringify!(screenSize)
			)
		);
	}
	test_field_screenSize();
	fn test_field_bXRandRAvailable() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_GET_STATUS_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).bXRandRAvailable) as usize - ptr as usize
			},
			24usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_GET_STATUS_PARAMS),
				"::",
				stringify!(bXRandRAvailable)
			)
		);
	}
	test_field_bXRandRAvailable();
	fn test_field_outputs() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_GET_STATUS_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).outputs) as usize - ptr as usize
			},
			28usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_GET_STATUS_PARAMS),
				"::",
				stringify!(outputs)
			)
		);
	}
	test_field_outputs();
	fn test_field_dwOutputNum() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_GET_STATUS_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwOutputNum) as usize - ptr as usize
			},
			768usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_GET_STATUS_PARAMS),
				"::",
				stringify!(dwOutputNum)
			)
		);
	}
	test_field_dwOutputNum();
	fn test_field_dwNvFBCVersion() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_GET_STATUS_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwNvFBCVersion) as usize - ptr as usize
			},
			772usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_GET_STATUS_PARAMS),
				"::",
				stringify!(dwNvFBCVersion)
			)
		);
	}
	test_field_dwNvFBCVersion();
	fn test_field_bInModeset() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_GET_STATUS_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).bInModeset) as usize - ptr as usize
			},
			776usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_GET_STATUS_PARAMS),
				"::",
				stringify!(bInModeset)
			)
		);
	}
	test_field_bInModeset();
}
#[doc = " Defines parameters for the ::NvFBCGetStatus() API call."]
pub type NVFBC_GET_STATUS_PARAMS = _NVFBC_GET_STATUS_PARAMS;
#[doc = " Defines parameters for the ::NvFBCCreateCaptureSession() API call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVFBC_CREATE_CAPTURE_SESSION_PARAMS {
	#[doc = " [in] Must be set to NVFBC_CREATE_CAPTURE_SESSION_PARAMS_VER"]
	pub dwVersion: u32,
	#[doc = " [in] Desired capture type."]
	#[doc = ""]
	#[doc = " Note that when specyfing ::NVFBC_CAPTURE_SHARED_CUDA NvFBC will try to"]
	#[doc = " dlopen() the corresponding libraries.  This means that NvFBC can run on"]
	#[doc = " a system without the CUDA library since it does not link against them."]
	pub eCaptureType: NVFBC_CAPTURE_TYPE,
	#[doc = " [in] What region of the framebuffer should be tracked."]
	pub eTrackingType: NVFBC_TRACKING_TYPE,
	#[doc = " [in] ID of the output to track if eTrackingType is set to"]
	#[doc = " ::NVFBC_TRACKING_OUTPUT."]
	pub dwOutputId: u32,
	#[doc = " [in] Crop the tracked region."]
	#[doc = ""]
	#[doc = " The coordinates are relative to the tracked region."]
	#[doc = ""]
	#[doc = " It can be set to 0 to capture the entire tracked region."]
	pub captureBox: NVFBC_BOX,
	#[doc = " [in] Desired size of the captured frame."]
	#[doc = ""]
	#[doc = " This parameter allow to scale the captured frame."]
	#[doc = ""]
	#[doc = " It can be set to 0 to disable frame resizing."]
	pub frameSize: NVFBC_SIZE,
	#[doc = " [in] Whether the mouse cursor should be composited to the frame."]
	#[doc = ""]
	#[doc = " Disabling the cursor will not generate new frames when only the cursor"]
	#[doc = " is moved."]
	pub bWithCursor: NVFBC_BOOL,
	#[doc = " [in] Whether NvFBC should not attempt to recover from modesets."]
	#[doc = ""]
	#[doc = " NvFBC is able to detect when a modeset event occured and can automatically"]
	#[doc = " re-create a capture session with the same settings as before, then resume"]
	#[doc = " its frame capture session transparently."]
	#[doc = ""]
	#[doc = " This option allows to disable this behavior.  NVFBC_ERR_MUST_RECREATE"]
	#[doc = " will be returned in that case."]
	#[doc = ""]
	#[doc = " It can be useful in the cases when an application needs to do some work"]
	#[doc = " between setting up a capture and grabbing the first frame."]
	#[doc = ""]
	#[doc = " For example: an application using the ToGL interface needs to register"]
	#[doc = " resources with EncodeAPI prior to encoding frames."]
	#[doc = ""]
	#[doc = " Note that during modeset recovery, NvFBC will try to re-create the"]
	#[doc = " capture session every second until it succeeds."]
	pub bDisableAutoModesetRecovery: NVFBC_BOOL,
	#[doc = " [in] Whether NvFBC should round the requested frameSize."]
	#[doc = ""]
	#[doc = " When disabled, NvFBC will not attempt to round the requested resolution."]
	#[doc = ""]
	#[doc = " However, some pixel formats have resolution requirements.  E.g., YUV/NV"]
	#[doc = " formats must have a width being a multiple of 4, and a height being a"]
	#[doc = " multiple of 2.  RGB formats don't have such requirements."]
	#[doc = ""]
	#[doc = " If the resolution doesn't meet the requirements of the format, then NvFBC"]
	#[doc = " will fail at setup time."]
	#[doc = ""]
	#[doc = " When enabled, NvFBC will round the requested width to the next multiple"]
	#[doc = " of 4 and the requested height to the next multiple of 2."]
	#[doc = ""]
	#[doc = " In this case, requesting any resolution will always work with every"]
	#[doc = " format.  However, an NvFBC client must be prepared to handle the case"]
	#[doc = " where the requested resolution is different than the captured resolution."]
	#[doc = ""]
	#[doc = " NVFBC_FRAME_GRAB_INFO::dwWidth and NVFBC_FRAME_GRAB_INFO::dwHeight should"]
	#[doc = " always be used for getting information about captured frames."]
	pub bRoundFrameSize: NVFBC_BOOL,
	#[doc = " [in] Rate in ms at which the display server generates new frames"]
	#[doc = ""]
	#[doc = " This controls the frequency at which the display server will generate"]
	#[doc = " new frames if new content is available.  This effectively controls the"]
	#[doc = " capture rate when using blocking calls."]
	#[doc = ""]
	#[doc = " Note that lower values will increase the CPU and GPU loads."]
	#[doc = ""]
	#[doc = " The default value is 16ms (~ 60 Hz)."]
	pub dwSamplingRateMs: u32,
	#[doc = " [in] Enable push model for frame capture"]
	#[doc = ""]
	#[doc = " When set to NVFBC_TRUE, the display server will generate frames whenever"]
	#[doc = " it receives a damage event from applications."]
	#[doc = ""]
	#[doc = " Setting this to NVFBC_TRUE will ignore ::dwSamplingRateMs."]
	#[doc = ""]
	#[doc = " Using push model with the NVFBC_*_GRAB_FLAGS_NOWAIT_IF_NEW_FRAME_READY"]
	#[doc = " capture flag should guarantee the shortest amount of time between an"]
	#[doc = " application rendering a frame and an NvFBC client capturing it, provided"]
	#[doc = " that the NvFBC client is able to process the frames quickly enough."]
	#[doc = ""]
	#[doc = " Note that applications running at high frame rates will increase CPU and"]
	#[doc = " GPU loads."]
	pub bPushModel: NVFBC_BOOL,
	#[doc = " [in] Allow direct capture"]
	#[doc = ""]
	#[doc = " Direct capture allows NvFBC to attach itself to a fullscreen graphics"]
	#[doc = " application. Whenever that application presents a frame, it makes a copy"]
	#[doc = " of it directly into a buffer owned by NvFBC thus bypassing the X server."]
	#[doc = ""]
	#[doc = " When direct capture is *not* enabled, the NVIDIA X driver generates a"]
	#[doc = " frame for NvFBC when it receives a damage event from an application if push"]
	#[doc = " model is enabled, or periodically checks if there are any pending damage"]
	#[doc = " events otherwise (see NVFBC_CREATE_CAPTURE_SESSION_PARAMS::dwSamplingRateMs)."]
	#[doc = ""]
	#[doc = " Direct capture is possible under the following conditions:"]
	#[doc = " - Direct capture is allowed"]
	#[doc = " - Push model is enabled (see NVFBC_CREATE_CAPTURE_SESSION_PARAMS::bPushModel)"]
	#[doc = " - The mouse cursor is not composited (see NVFBC_CREATE_CAPTURE_SESSION_PARAMS::bWithCursor)"]
	#[doc = " - No viewport transformation is required. This happens when the remote"]
	#[doc = "   desktop is e.g. rotated."]
	#[doc = ""]
	#[doc = " When direct capture is possible, NvFBC will automatically attach itself"]
	#[doc = " to a fullscreen unoccluded application, if such exists."]
	#[doc = ""]
	#[doc = " Notes:"]
	#[doc = " - This includes compositing desktops such as GNOME (e.g., gnome-shell"]
	#[doc = "   is the fullscreen unoccluded application)."]
	#[doc = " - There can be only one fullscreen unoccluded application at a time."]
	#[doc = " - The NVIDIA X driver monitors which application qualifies or no"]
	#[doc = "   longer qualifies."]
	#[doc = ""]
	#[doc = " For example, if a fullscreen application is launched in GNOME, NvFBC will"]
	#[doc = " detach from gnome-shell and attach to that application."]
	#[doc = ""]
	#[doc = " Attaching and detaching happens automatically from the perspective of an"]
	#[doc = " NvFBC client. When detaching from an application, the X driver will"]
	#[doc = " transparently resume generating frames for NvFBC."]
	#[doc = ""]
	#[doc = " An application can know whether a given frame was obtained through"]
	#[doc = " direct capture by checking NVFBC_FRAME_GRAB_INFO::bDirectCapture."]
	pub bAllowDirectCapture: NVFBC_BOOL,
}
#[test]
fn bindgen_test_layout__NVFBC_CREATE_CAPTURE_SESSION_PARAMS() {
	assert_eq!(
		::std::mem::size_of::<_NVFBC_CREATE_CAPTURE_SESSION_PARAMS>(),
		64usize,
		concat!("Size of: ", stringify!(_NVFBC_CREATE_CAPTURE_SESSION_PARAMS))
	);
	assert_eq!(
		::std::mem::align_of::<_NVFBC_CREATE_CAPTURE_SESSION_PARAMS>(),
		4usize,
		concat!("Alignment of ", stringify!(_NVFBC_CREATE_CAPTURE_SESSION_PARAMS))
	);
	fn test_field_dwVersion() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_CREATE_CAPTURE_SESSION_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwVersion) as usize - ptr as usize
			},
			0usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_CREATE_CAPTURE_SESSION_PARAMS),
				"::",
				stringify!(dwVersion)
			)
		);
	}
	test_field_dwVersion();
	fn test_field_eCaptureType() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_CREATE_CAPTURE_SESSION_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).eCaptureType) as usize - ptr as usize
			},
			4usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_CREATE_CAPTURE_SESSION_PARAMS),
				"::",
				stringify!(eCaptureType)
			)
		);
	}
	test_field_eCaptureType();
	fn test_field_eTrackingType() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_CREATE_CAPTURE_SESSION_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).eTrackingType) as usize - ptr as usize
			},
			8usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_CREATE_CAPTURE_SESSION_PARAMS),
				"::",
				stringify!(eTrackingType)
			)
		);
	}
	test_field_eTrackingType();
	fn test_field_dwOutputId() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_CREATE_CAPTURE_SESSION_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwOutputId) as usize - ptr as usize
			},
			12usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_CREATE_CAPTURE_SESSION_PARAMS),
				"::",
				stringify!(dwOutputId)
			)
		);
	}
	test_field_dwOutputId();
	fn test_field_captureBox() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_CREATE_CAPTURE_SESSION_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).captureBox) as usize - ptr as usize
			},
			16usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_CREATE_CAPTURE_SESSION_PARAMS),
				"::",
				stringify!(captureBox)
			)
		);
	}
	test_field_captureBox();
	fn test_field_frameSize() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_CREATE_CAPTURE_SESSION_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).frameSize) as usize - ptr as usize
			},
			32usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_CREATE_CAPTURE_SESSION_PARAMS),
				"::",
				stringify!(frameSize)
			)
		);
	}
	test_field_frameSize();
	fn test_field_bWithCursor() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_CREATE_CAPTURE_SESSION_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).bWithCursor) as usize - ptr as usize
			},
			40usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_CREATE_CAPTURE_SESSION_PARAMS),
				"::",
				stringify!(bWithCursor)
			)
		);
	}
	test_field_bWithCursor();
	fn test_field_bDisableAutoModesetRecovery() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_CREATE_CAPTURE_SESSION_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).bDisableAutoModesetRecovery) as usize - ptr as usize
			},
			44usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_CREATE_CAPTURE_SESSION_PARAMS),
				"::",
				stringify!(bDisableAutoModesetRecovery)
			)
		);
	}
	test_field_bDisableAutoModesetRecovery();
	fn test_field_bRoundFrameSize() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_CREATE_CAPTURE_SESSION_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).bRoundFrameSize) as usize - ptr as usize
			},
			48usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_CREATE_CAPTURE_SESSION_PARAMS),
				"::",
				stringify!(bRoundFrameSize)
			)
		);
	}
	test_field_bRoundFrameSize();
	fn test_field_dwSamplingRateMs() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_CREATE_CAPTURE_SESSION_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwSamplingRateMs) as usize - ptr as usize
			},
			52usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_CREATE_CAPTURE_SESSION_PARAMS),
				"::",
				stringify!(dwSamplingRateMs)
			)
		);
	}
	test_field_dwSamplingRateMs();
	fn test_field_bPushModel() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_CREATE_CAPTURE_SESSION_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).bPushModel) as usize - ptr as usize
			},
			56usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_CREATE_CAPTURE_SESSION_PARAMS),
				"::",
				stringify!(bPushModel)
			)
		);
	}
	test_field_bPushModel();
	fn test_field_bAllowDirectCapture() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_CREATE_CAPTURE_SESSION_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).bAllowDirectCapture) as usize - ptr as usize
			},
			60usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_CREATE_CAPTURE_SESSION_PARAMS),
				"::",
				stringify!(bAllowDirectCapture)
			)
		);
	}
	test_field_bAllowDirectCapture();
}
#[doc = " Defines parameters for the ::NvFBCCreateCaptureSession() API call."]
pub type NVFBC_CREATE_CAPTURE_SESSION_PARAMS = _NVFBC_CREATE_CAPTURE_SESSION_PARAMS;
#[doc = " Defines parameters for the ::NvFBCDestroyCaptureSession() API call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVFBC_DESTROY_CAPTURE_SESSION_PARAMS {
	#[doc = " [in] Must be set to NVFBC_DESTROY_CAPTURE_SESSION_PARAMS_VER"]
	pub dwVersion: u32,
}
#[test]
fn bindgen_test_layout__NVFBC_DESTROY_CAPTURE_SESSION_PARAMS() {
	assert_eq!(
		::std::mem::size_of::<_NVFBC_DESTROY_CAPTURE_SESSION_PARAMS>(),
		4usize,
		concat!("Size of: ", stringify!(_NVFBC_DESTROY_CAPTURE_SESSION_PARAMS))
	);
	assert_eq!(
		::std::mem::align_of::<_NVFBC_DESTROY_CAPTURE_SESSION_PARAMS>(),
		4usize,
		concat!("Alignment of ", stringify!(_NVFBC_DESTROY_CAPTURE_SESSION_PARAMS))
	);
	fn test_field_dwVersion() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_DESTROY_CAPTURE_SESSION_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwVersion) as usize - ptr as usize
			},
			0usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_DESTROY_CAPTURE_SESSION_PARAMS),
				"::",
				stringify!(dwVersion)
			)
		);
	}
	test_field_dwVersion();
}
#[doc = " Defines parameters for the ::NvFBCDestroyCaptureSession() API call."]
pub type NVFBC_DESTROY_CAPTURE_SESSION_PARAMS = _NVFBC_DESTROY_CAPTURE_SESSION_PARAMS;
#[doc = " Defines parameters for the ::NvFBCBindContext() API call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVFBC_BIND_CONTEXT_PARAMS {
	#[doc = " [in] Must be set to NVFBC_BIND_CONTEXT_PARAMS_VER"]
	pub dwVersion: u32,
}
#[test]
fn bindgen_test_layout__NVFBC_BIND_CONTEXT_PARAMS() {
	assert_eq!(
		::std::mem::size_of::<_NVFBC_BIND_CONTEXT_PARAMS>(),
		4usize,
		concat!("Size of: ", stringify!(_NVFBC_BIND_CONTEXT_PARAMS))
	);
	assert_eq!(
		::std::mem::align_of::<_NVFBC_BIND_CONTEXT_PARAMS>(),
		4usize,
		concat!("Alignment of ", stringify!(_NVFBC_BIND_CONTEXT_PARAMS))
	);
	fn test_field_dwVersion() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_BIND_CONTEXT_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwVersion) as usize - ptr as usize
			},
			0usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_BIND_CONTEXT_PARAMS),
				"::",
				stringify!(dwVersion)
			)
		);
	}
	test_field_dwVersion();
}
#[doc = " Defines parameters for the ::NvFBCBindContext() API call."]
pub type NVFBC_BIND_CONTEXT_PARAMS = _NVFBC_BIND_CONTEXT_PARAMS;
#[doc = " Defines parameters for the ::NvFBCReleaseContext() API call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVFBC_RELEASE_CONTEXT_PARAMS {
	#[doc = " [in] Must be set to NVFBC_RELEASE_CONTEXT_PARAMS_VER"]
	pub dwVersion: u32,
}
#[test]
fn bindgen_test_layout__NVFBC_RELEASE_CONTEXT_PARAMS() {
	assert_eq!(
		::std::mem::size_of::<_NVFBC_RELEASE_CONTEXT_PARAMS>(),
		4usize,
		concat!("Size of: ", stringify!(_NVFBC_RELEASE_CONTEXT_PARAMS))
	);
	assert_eq!(
		::std::mem::align_of::<_NVFBC_RELEASE_CONTEXT_PARAMS>(),
		4usize,
		concat!("Alignment of ", stringify!(_NVFBC_RELEASE_CONTEXT_PARAMS))
	);
	fn test_field_dwVersion() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_RELEASE_CONTEXT_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwVersion) as usize - ptr as usize
			},
			0usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_RELEASE_CONTEXT_PARAMS),
				"::",
				stringify!(dwVersion)
			)
		);
	}
	test_field_dwVersion();
}
#[doc = " Defines parameters for the ::NvFBCReleaseContext() API call."]
pub type NVFBC_RELEASE_CONTEXT_PARAMS = _NVFBC_RELEASE_CONTEXT_PARAMS;
#[doc = " Default, capturing waits for a new frame or mouse move."]
#[doc = ""]
#[doc = " The default behavior of blocking grabs is to wait for a new frame until"]
#[doc = " after the call was made.  But it's possible that there is a frame already"]
#[doc = " ready that the client hasn't seen."]
#[doc = " \\see NVFBC_TOSYS_GRAB_FLAGS_NOWAIT_IF_NEW_FRAME_READY"]
pub const NVFBC_TOSYS_GRAB_FLAGS_NVFBC_TOSYS_GRAB_FLAGS_NOFLAGS: NVFBC_TOSYS_GRAB_FLAGS = 0;
#[doc = " Capturing does not wait for a new frame nor a mouse move."]
#[doc = ""]
#[doc = " It is therefore possible to capture the same frame multiple times."]
#[doc = " When this occurs, the dwCurrentFrame parameter of the"]
#[doc = " NVFBC_FRAME_GRAB_INFO structure is not incremented."]
pub const NVFBC_TOSYS_GRAB_FLAGS_NVFBC_TOSYS_GRAB_FLAGS_NOWAIT: NVFBC_TOSYS_GRAB_FLAGS = 1;
#[doc = " Forces the destination buffer to be refreshed even if the frame has not"]
#[doc = " changed since previous capture."]
#[doc = ""]
#[doc = " By default, if the captured frame is identical to the previous one, NvFBC"]
#[doc = " will omit one copy and not update the destination buffer."]
#[doc = ""]
#[doc = " Setting that flag will prevent this behavior.  This can be useful e.g.,"]
#[doc = " if the application has modified the buffer in the meantime."]
pub const NVFBC_TOSYS_GRAB_FLAGS_NVFBC_TOSYS_GRAB_FLAGS_FORCE_REFRESH: NVFBC_TOSYS_GRAB_FLAGS = 2;
#[doc = " Similar to NVFBC_TOSYS_GRAB_FLAGS_NOFLAGS, except that the capture will"]
#[doc = " not wait if there is already a frame available that the client has"]
#[doc = " never seen yet."]
pub const NVFBC_TOSYS_GRAB_FLAGS_NVFBC_TOSYS_GRAB_FLAGS_NOWAIT_IF_NEW_FRAME_READY: NVFBC_TOSYS_GRAB_FLAGS = 4;
#[doc = " Defines flags that can be used when capturing to system memory."]
pub type NVFBC_TOSYS_GRAB_FLAGS = ::std::os::raw::c_uint;
#[doc = " Defines parameters for the ::NvFBCToSysSetUp() API call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVFBC_TOSYS_SETUP_PARAMS {
	#[doc = " [in] Must be set to NVFBC_TOSYS_SETUP_PARAMS_VER"]
	pub dwVersion: u32,
	#[doc = " [in] Desired buffer format."]
	pub eBufferFormat: NVFBC_BUFFER_FORMAT,
	#[doc = " [out] Pointer to a pointer to a buffer in system memory."]
	#[doc = ""]
	#[doc = " This buffer contains the pixel value of the requested format.  Refer to"]
	#[doc = " the description of the buffer formats to understand the memory layout."]
	#[doc = ""]
	#[doc = " The application does not need to allocate memory for this buffer.  It"]
	#[doc = " should not free this buffer either.  This buffer is automatically"]
	#[doc = " re-allocated when needed (e.g., when the resolution changes)."]
	#[doc = ""]
	#[doc = " This buffer is allocated by the NvFBC library to the proper size.  This"]
	#[doc = " size is returned in the dwByteSize field of the"]
	#[doc = " ::NVFBC_FRAME_GRAB_INFO structure."]
	pub ppBuffer: *mut *mut ::std::os::raw::c_void,
	#[doc = " [in] Whether differential maps should be generated."]
	pub bWithDiffMap: NVFBC_BOOL,
	#[doc = " [out] Pointer to a pointer to a buffer in system memory."]
	#[doc = ""]
	#[doc = " This buffer contains the differential map of two frames.  It must be read"]
	#[doc = " as an array of unsigned char.  Each unsigned char is either 0 or"]
	#[doc = " non-zero.  0 means that the pixel value at the given location has not"]
	#[doc = " changed since the previous captured frame.  Non-zero means that the pixel"]
	#[doc = " value has changed."]
	#[doc = ""]
	#[doc = " The application does not need to allocate memory for this buffer.  It"]
	#[doc = " should not free this buffer either.  This buffer is automatically"]
	#[doc = " re-allocated when needed (e.g., when the resolution changes)."]
	#[doc = ""]
	#[doc = " This buffer is allocated by the NvFBC library to the proper size.  The"]
	#[doc = " size of the differential map is returned in ::diffMapSize."]
	#[doc = ""]
	#[doc = " This option is not compatible with the ::NVFBC_BUFFER_FORMAT_YUV420P and"]
	#[doc = " ::NVFBC_BUFFER_FORMAT_YUV444P buffer formats."]
	pub ppDiffMap: *mut *mut ::std::os::raw::c_void,
	#[doc = " [in] Scaling factor of the differential maps."]
	#[doc = ""]
	#[doc = " For example, a scaling factor of 16 means that one pixel of the diffmap"]
	#[doc = " will represent 16x16 pixels of the original frames."]
	#[doc = ""]
	#[doc = " If any of these 16x16 pixels is different between the current and the"]
	#[doc = " previous frame, then the corresponding pixel in the diffmap will be set"]
	#[doc = " to non-zero."]
	#[doc = ""]
	#[doc = " The default scaling factor is 1.  A dwDiffMapScalingFactor of 0 will be"]
	#[doc = " set to 1."]
	pub dwDiffMapScalingFactor: u32,
	#[doc = " [out] Size of the differential map."]
	#[doc = ""]
	#[doc = " Only set if bWithDiffMap is set to NVFBC_TRUE."]
	pub diffMapSize: NVFBC_SIZE,
}
#[test]
fn bindgen_test_layout__NVFBC_TOSYS_SETUP_PARAMS() {
	assert_eq!(
		::std::mem::size_of::<_NVFBC_TOSYS_SETUP_PARAMS>(),
		48usize,
		concat!("Size of: ", stringify!(_NVFBC_TOSYS_SETUP_PARAMS))
	);
	assert_eq!(
		::std::mem::align_of::<_NVFBC_TOSYS_SETUP_PARAMS>(),
		8usize,
		concat!("Alignment of ", stringify!(_NVFBC_TOSYS_SETUP_PARAMS))
	);
	fn test_field_dwVersion() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOSYS_SETUP_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwVersion) as usize - ptr as usize
			},
			0usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOSYS_SETUP_PARAMS),
				"::",
				stringify!(dwVersion)
			)
		);
	}
	test_field_dwVersion();
	fn test_field_eBufferFormat() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOSYS_SETUP_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).eBufferFormat) as usize - ptr as usize
			},
			4usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOSYS_SETUP_PARAMS),
				"::",
				stringify!(eBufferFormat)
			)
		);
	}
	test_field_eBufferFormat();
	fn test_field_ppBuffer() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOSYS_SETUP_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).ppBuffer) as usize - ptr as usize
			},
			8usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOSYS_SETUP_PARAMS),
				"::",
				stringify!(ppBuffer)
			)
		);
	}
	test_field_ppBuffer();
	fn test_field_bWithDiffMap() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOSYS_SETUP_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).bWithDiffMap) as usize - ptr as usize
			},
			16usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOSYS_SETUP_PARAMS),
				"::",
				stringify!(bWithDiffMap)
			)
		);
	}
	test_field_bWithDiffMap();
	fn test_field_ppDiffMap() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOSYS_SETUP_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).ppDiffMap) as usize - ptr as usize
			},
			24usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOSYS_SETUP_PARAMS),
				"::",
				stringify!(ppDiffMap)
			)
		);
	}
	test_field_ppDiffMap();
	fn test_field_dwDiffMapScalingFactor() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOSYS_SETUP_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwDiffMapScalingFactor) as usize - ptr as usize
			},
			32usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOSYS_SETUP_PARAMS),
				"::",
				stringify!(dwDiffMapScalingFactor)
			)
		);
	}
	test_field_dwDiffMapScalingFactor();
	fn test_field_diffMapSize() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOSYS_SETUP_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).diffMapSize) as usize - ptr as usize
			},
			36usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOSYS_SETUP_PARAMS),
				"::",
				stringify!(diffMapSize)
			)
		);
	}
	test_field_diffMapSize();
}
#[doc = " Defines parameters for the ::NvFBCToSysSetUp() API call."]
pub type NVFBC_TOSYS_SETUP_PARAMS = _NVFBC_TOSYS_SETUP_PARAMS;
#[doc = " Defines parameters for the ::NvFBCToSysGrabFrame() API call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVFBC_TOSYS_GRAB_FRAME_PARAMS {
	#[doc = " [in] Must be set to NVFBC_TOSYS_GRAB_FRAME_PARAMS_VER"]
	pub dwVersion: u32,
	#[doc = " [in] Flags defining the behavior of this frame capture."]
	pub dwFlags: u32,
	#[doc = " [out] Information about the captured frame."]
	#[doc = ""]
	#[doc = " Can be NULL."]
	pub pFrameGrabInfo: *mut NVFBC_FRAME_GRAB_INFO,
	#[doc = " [in] Wait timeout in milliseconds."]
	#[doc = ""]
	#[doc = " When capturing frames with the NVFBC_TOSYS_GRAB_FLAGS_NOFLAGS or"]
	#[doc = " NVFBC_TOSYS_GRAB_FLAGS_NOWAIT_IF_NEW_FRAME_READY flags,"]
	#[doc = " NvFBC will wait for a new frame or mouse move until the below timer"]
	#[doc = " expires."]
	#[doc = ""]
	#[doc = " When timing out, the last captured frame will be returned.  Note that as"]
	#[doc = " long as the NVFBC_TOSYS_GRAB_FLAGS_FORCE_REFRESH flag is not set,"]
	#[doc = " returning an old frame will incur no performance penalty."]
	#[doc = ""]
	#[doc = " NvFBC clients can use the return value of the grab frame operation to"]
	#[doc = " find out whether a new frame was captured, or the timer expired."]
	#[doc = ""]
	#[doc = " Note that the behavior of blocking calls is to wait for a new frame"]
	#[doc = " *after* the call has been made.  When using timeouts, it is possible"]
	#[doc = " that NvFBC will return a new frame (e.g., it has never been captured"]
	#[doc = " before) even though no new frame was generated after the grab call."]
	#[doc = ""]
	#[doc = " For the precise definition of what constitutes a new frame, see"]
	#[doc = " ::bIsNewFrame."]
	#[doc = ""]
	#[doc = " Set to 0 to disable timeouts."]
	pub dwTimeoutMs: u32,
}
#[test]
fn bindgen_test_layout__NVFBC_TOSYS_GRAB_FRAME_PARAMS() {
	assert_eq!(
		::std::mem::size_of::<_NVFBC_TOSYS_GRAB_FRAME_PARAMS>(),
		24usize,
		concat!("Size of: ", stringify!(_NVFBC_TOSYS_GRAB_FRAME_PARAMS))
	);
	assert_eq!(
		::std::mem::align_of::<_NVFBC_TOSYS_GRAB_FRAME_PARAMS>(),
		8usize,
		concat!("Alignment of ", stringify!(_NVFBC_TOSYS_GRAB_FRAME_PARAMS))
	);
	fn test_field_dwVersion() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOSYS_GRAB_FRAME_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwVersion) as usize - ptr as usize
			},
			0usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOSYS_GRAB_FRAME_PARAMS),
				"::",
				stringify!(dwVersion)
			)
		);
	}
	test_field_dwVersion();
	fn test_field_dwFlags() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOSYS_GRAB_FRAME_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwFlags) as usize - ptr as usize
			},
			4usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOSYS_GRAB_FRAME_PARAMS),
				"::",
				stringify!(dwFlags)
			)
		);
	}
	test_field_dwFlags();
	fn test_field_pFrameGrabInfo() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOSYS_GRAB_FRAME_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).pFrameGrabInfo) as usize - ptr as usize
			},
			8usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOSYS_GRAB_FRAME_PARAMS),
				"::",
				stringify!(pFrameGrabInfo)
			)
		);
	}
	test_field_pFrameGrabInfo();
	fn test_field_dwTimeoutMs() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOSYS_GRAB_FRAME_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwTimeoutMs) as usize - ptr as usize
			},
			16usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOSYS_GRAB_FRAME_PARAMS),
				"::",
				stringify!(dwTimeoutMs)
			)
		);
	}
	test_field_dwTimeoutMs();
}
#[doc = " Defines parameters for the ::NvFBCToSysGrabFrame() API call."]
pub type NVFBC_TOSYS_GRAB_FRAME_PARAMS = _NVFBC_TOSYS_GRAB_FRAME_PARAMS;
#[doc = " Default, capturing waits for a new frame or mouse move."]
#[doc = ""]
#[doc = " The default behavior of blocking grabs is to wait for a new frame until"]
#[doc = " after the call was made.  But it's possible that there is a frame already"]
#[doc = " ready that the client hasn't seen."]
#[doc = " \\see NVFBC_TOCUDA_GRAB_FLAGS_NOWAIT_IF_NEW_FRAME_READY"]
pub const NVFBC_TOCUDA_FLAGS_NVFBC_TOCUDA_GRAB_FLAGS_NOFLAGS: NVFBC_TOCUDA_FLAGS = 0;
#[doc = " Capturing does not wait for a new frame nor a mouse move."]
#[doc = ""]
#[doc = " It is therefore possible to capture the same frame multiple times."]
#[doc = " When this occurs, the dwCurrentFrame parameter of the"]
#[doc = " NVFBC_FRAME_GRAB_INFO structure is not incremented."]
pub const NVFBC_TOCUDA_FLAGS_NVFBC_TOCUDA_GRAB_FLAGS_NOWAIT: NVFBC_TOCUDA_FLAGS = 1;
#[doc = " [in] Forces the destination buffer to be refreshed even if the frame"]
#[doc = " has not changed since previous capture."]
#[doc = ""]
#[doc = " By default, if the captured frame is identical to the previous one, NvFBC"]
#[doc = " will omit one copy and not update the destination buffer."]
#[doc = ""]
#[doc = " Setting that flag will prevent this behavior.  This can be useful e.g.,"]
#[doc = " if the application has modified the buffer in the meantime."]
pub const NVFBC_TOCUDA_FLAGS_NVFBC_TOCUDA_GRAB_FLAGS_FORCE_REFRESH: NVFBC_TOCUDA_FLAGS = 2;
#[doc = " Similar to NVFBC_TOCUDA_GRAB_FLAGS_NOFLAGS, except that the capture will"]
#[doc = " not wait if there is already a frame available that the client has"]
#[doc = " never seen yet."]
pub const NVFBC_TOCUDA_FLAGS_NVFBC_TOCUDA_GRAB_FLAGS_NOWAIT_IF_NEW_FRAME_READY: NVFBC_TOCUDA_FLAGS = 4;
#[doc = " Defines flags that can be used when capturing to a CUDA buffer in video memory."]
pub type NVFBC_TOCUDA_FLAGS = ::std::os::raw::c_uint;
#[doc = " Defines parameters for the ::NvFBCToCudaSetUp() API call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVFBC_TOCUDA_SETUP_PARAMS {
	#[doc = " [in] Must be set to NVFBC_TOCUDA_SETUP_PARAMS_VER"]
	pub dwVersion: u32,
	#[doc = " [in] Desired buffer format."]
	pub eBufferFormat: NVFBC_BUFFER_FORMAT,
}
#[test]
fn bindgen_test_layout__NVFBC_TOCUDA_SETUP_PARAMS() {
	assert_eq!(
		::std::mem::size_of::<_NVFBC_TOCUDA_SETUP_PARAMS>(),
		8usize,
		concat!("Size of: ", stringify!(_NVFBC_TOCUDA_SETUP_PARAMS))
	);
	assert_eq!(
		::std::mem::align_of::<_NVFBC_TOCUDA_SETUP_PARAMS>(),
		4usize,
		concat!("Alignment of ", stringify!(_NVFBC_TOCUDA_SETUP_PARAMS))
	);
	fn test_field_dwVersion() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOCUDA_SETUP_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwVersion) as usize - ptr as usize
			},
			0usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOCUDA_SETUP_PARAMS),
				"::",
				stringify!(dwVersion)
			)
		);
	}
	test_field_dwVersion();
	fn test_field_eBufferFormat() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOCUDA_SETUP_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).eBufferFormat) as usize - ptr as usize
			},
			4usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOCUDA_SETUP_PARAMS),
				"::",
				stringify!(eBufferFormat)
			)
		);
	}
	test_field_eBufferFormat();
}
#[doc = " Defines parameters for the ::NvFBCToCudaSetUp() API call."]
pub type NVFBC_TOCUDA_SETUP_PARAMS = _NVFBC_TOCUDA_SETUP_PARAMS;
#[doc = " Defines parameters for the ::NvFBCToCudaGrabFrame() API call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVFBC_TOCUDA_GRAB_FRAME_PARAMS {
	#[doc = " [in] Must be set to NVFBC_TOCUDA_GRAB_FRAME_PARAMS_VER."]
	pub dwVersion: u32,
	#[doc = " [in] Flags defining the behavior of this frame capture."]
	pub dwFlags: u32,
	#[doc = " [out] Pointer to a ::CUdeviceptr"]
	#[doc = ""]
	#[doc = " The application does not need to allocate memory for this CUDA device."]
	#[doc = ""]
	#[doc = " The application does need to create its own CUDA context to use this"]
	#[doc = " CUDA device."]
	#[doc = ""]
	#[doc = " This ::CUdeviceptr will be mapped to a segment in video memory containing"]
	#[doc = " the frame.  It is not possible to process a CUDA device while capturing"]
	#[doc = " a new frame.  If the application wants to do so, it must copy the CUDA"]
	#[doc = " device using ::cuMemcpyDtoD or ::cuMemcpyDtoH beforehand."]
	pub pCUDADeviceBuffer: *mut ::std::os::raw::c_void,
	#[doc = " [out] Information about the captured frame."]
	#[doc = ""]
	#[doc = " Can be NULL."]
	pub pFrameGrabInfo: *mut NVFBC_FRAME_GRAB_INFO,
	#[doc = " [in] Wait timeout in milliseconds."]
	#[doc = ""]
	#[doc = " When capturing frames with the NVFBC_TOCUDA_GRAB_FLAGS_NOFLAGS or"]
	#[doc = " NVFBC_TOCUDA_GRAB_FLAGS_NOWAIT_IF_NEW_FRAME_READY flags,"]
	#[doc = " NvFBC will wait for a new frame or mouse move until the below timer"]
	#[doc = " expires."]
	#[doc = ""]
	#[doc = " When timing out, the last captured frame will be returned.  Note that as"]
	#[doc = " long as the NVFBC_TOCUDA_GRAB_FLAGS_FORCE_REFRESH flag is not set,"]
	#[doc = " returning an old frame will incur no performance penalty."]
	#[doc = ""]
	#[doc = " NvFBC clients can use the return value of the grab frame operation to"]
	#[doc = " find out whether a new frame was captured, or the timer expired."]
	#[doc = ""]
	#[doc = " Note that the behavior of blocking calls is to wait for a new frame"]
	#[doc = " *after* the call has been made.  When using timeouts, it is possible"]
	#[doc = " that NvFBC will return a new frame (e.g., it has never been captured"]
	#[doc = " before) even though no new frame was generated after the grab call."]
	#[doc = ""]
	#[doc = " For the precise definition of what constitutes a new frame, see"]
	#[doc = " ::bIsNewFrame."]
	#[doc = ""]
	#[doc = " Set to 0 to disable timeouts."]
	pub dwTimeoutMs: u32,
}
#[test]
fn bindgen_test_layout__NVFBC_TOCUDA_GRAB_FRAME_PARAMS() {
	assert_eq!(
		::std::mem::size_of::<_NVFBC_TOCUDA_GRAB_FRAME_PARAMS>(),
		32usize,
		concat!("Size of: ", stringify!(_NVFBC_TOCUDA_GRAB_FRAME_PARAMS))
	);
	assert_eq!(
		::std::mem::align_of::<_NVFBC_TOCUDA_GRAB_FRAME_PARAMS>(),
		8usize,
		concat!("Alignment of ", stringify!(_NVFBC_TOCUDA_GRAB_FRAME_PARAMS))
	);
	fn test_field_dwVersion() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOCUDA_GRAB_FRAME_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwVersion) as usize - ptr as usize
			},
			0usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOCUDA_GRAB_FRAME_PARAMS),
				"::",
				stringify!(dwVersion)
			)
		);
	}
	test_field_dwVersion();
	fn test_field_dwFlags() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOCUDA_GRAB_FRAME_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwFlags) as usize - ptr as usize
			},
			4usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOCUDA_GRAB_FRAME_PARAMS),
				"::",
				stringify!(dwFlags)
			)
		);
	}
	test_field_dwFlags();
	fn test_field_pCUDADeviceBuffer() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOCUDA_GRAB_FRAME_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).pCUDADeviceBuffer) as usize - ptr as usize
			},
			8usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOCUDA_GRAB_FRAME_PARAMS),
				"::",
				stringify!(pCUDADeviceBuffer)
			)
		);
	}
	test_field_pCUDADeviceBuffer();
	fn test_field_pFrameGrabInfo() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOCUDA_GRAB_FRAME_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).pFrameGrabInfo) as usize - ptr as usize
			},
			16usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOCUDA_GRAB_FRAME_PARAMS),
				"::",
				stringify!(pFrameGrabInfo)
			)
		);
	}
	test_field_pFrameGrabInfo();
	fn test_field_dwTimeoutMs() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOCUDA_GRAB_FRAME_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwTimeoutMs) as usize - ptr as usize
			},
			24usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOCUDA_GRAB_FRAME_PARAMS),
				"::",
				stringify!(dwTimeoutMs)
			)
		);
	}
	test_field_dwTimeoutMs();
}
#[doc = " Defines parameters for the ::NvFBCToCudaGrabFrame() API call."]
pub type NVFBC_TOCUDA_GRAB_FRAME_PARAMS = _NVFBC_TOCUDA_GRAB_FRAME_PARAMS;
#[doc = " Default, capturing waits for a new frame or mouse move."]
#[doc = ""]
#[doc = " The default behavior of blocking grabs is to wait for a new frame until"]
#[doc = " after the call was made.  But it's possible that there is a frame already"]
#[doc = " ready that the client hasn't seen."]
#[doc = " \\see NVFBC_TOGL_GRAB_FLAGS_NOWAIT_IF_NEW_FRAME_READY"]
pub const NVFBC_TOGL_FLAGS_NVFBC_TOGL_GRAB_FLAGS_NOFLAGS: NVFBC_TOGL_FLAGS = 0;
#[doc = " Capturing does not wait for a new frame nor a mouse move."]
#[doc = ""]
#[doc = " It is therefore possible to capture the same frame multiple times."]
#[doc = " When this occurs, the dwCurrentFrame parameter of the"]
#[doc = " NVFBC_FRAME_GRAB_INFO structure is not incremented."]
pub const NVFBC_TOGL_FLAGS_NVFBC_TOGL_GRAB_FLAGS_NOWAIT: NVFBC_TOGL_FLAGS = 1;
#[doc = " [in] Forces the destination buffer to be refreshed even if the frame"]
#[doc = " has not changed since previous capture."]
#[doc = ""]
#[doc = " By default, if the captured frame is identical to the previous one, NvFBC"]
#[doc = " will omit one copy and not update the destination buffer."]
#[doc = ""]
#[doc = " Setting that flag will prevent this behavior.  This can be useful e.g.,"]
#[doc = " if the application has modified the buffer in the meantime."]
pub const NVFBC_TOGL_FLAGS_NVFBC_TOGL_GRAB_FLAGS_FORCE_REFRESH: NVFBC_TOGL_FLAGS = 2;
#[doc = " Similar to NVFBC_TOGL_GRAB_FLAGS_NOFLAGS, except that the capture will"]
#[doc = " not wait if there is already a frame available that the client has"]
#[doc = " never seen yet."]
pub const NVFBC_TOGL_FLAGS_NVFBC_TOGL_GRAB_FLAGS_NOWAIT_IF_NEW_FRAME_READY: NVFBC_TOGL_FLAGS = 4;
#[doc = " Defines flags that can be used when capturing to an OpenGL buffer in video memory."]
pub type NVFBC_TOGL_FLAGS = ::std::os::raw::c_uint;
#[doc = " Defines parameters for the ::NvFBCToGLSetUp() API call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVFBC_TOGL_SETUP_PARAMS {
	#[doc = " [in] Must be set to NVFBC_TOGL_SETUP_PARAMS_VER"]
	pub dwVersion: u32,
	#[doc = " [in] Desired buffer format."]
	pub eBufferFormat: NVFBC_BUFFER_FORMAT,
	#[doc = " [in] Whether differential maps should be generated."]
	pub bWithDiffMap: NVFBC_BOOL,
	#[doc = " [out] Pointer to a pointer to a buffer in system memory."]
	#[doc = ""]
	#[doc = " \\see NVFBC_TOSYS_SETUP_PARAMS::ppDiffMap"]
	pub ppDiffMap: *mut *mut ::std::os::raw::c_void,
	#[doc = " [in] Scaling factor of the differential maps."]
	#[doc = ""]
	#[doc = " \\see NVFBC_TOSYS_SETUP_PARAMS::dwDiffMapScalingFactor"]
	pub dwDiffMapScalingFactor: u32,
	#[doc = " [out] List of GL textures that will store the captured frames."]
	#[doc = ""]
	#[doc = " This array is 0 terminated.  The number of textures varies depending on"]
	#[doc = " the capture settings (such as whether diffmaps are enabled)."]
	#[doc = ""]
	#[doc = " An application wishing to interop with, for example, EncodeAPI will need"]
	#[doc = " to register these textures prior to start encoding frames."]
	#[doc = ""]
	#[doc = " After each frame capture, the texture holding the current frame will be"]
	#[doc = " returned in NVFBC_TOGL_GRAB_FRAME_PARAMS::dwTexture."]
	pub dwTextures: [u32; 2usize],
	#[doc = " [out] GL target to which the texture should be bound."]
	pub dwTexTarget: u32,
	#[doc = " [out] GL format of the textures."]
	pub dwTexFormat: u32,
	#[doc = " [out] GL type of the textures."]
	pub dwTexType: u32,
	#[doc = " [out] Size of the differential map."]
	#[doc = ""]
	#[doc = " Only set if bWithDiffMap is set to NVFBC_TRUE."]
	pub diffMapSize: NVFBC_SIZE,
}
#[test]
fn bindgen_test_layout__NVFBC_TOGL_SETUP_PARAMS() {
	assert_eq!(
		::std::mem::size_of::<_NVFBC_TOGL_SETUP_PARAMS>(),
		56usize,
		concat!("Size of: ", stringify!(_NVFBC_TOGL_SETUP_PARAMS))
	);
	assert_eq!(
		::std::mem::align_of::<_NVFBC_TOGL_SETUP_PARAMS>(),
		8usize,
		concat!("Alignment of ", stringify!(_NVFBC_TOGL_SETUP_PARAMS))
	);
	fn test_field_dwVersion() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOGL_SETUP_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwVersion) as usize - ptr as usize
			},
			0usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOGL_SETUP_PARAMS),
				"::",
				stringify!(dwVersion)
			)
		);
	}
	test_field_dwVersion();
	fn test_field_eBufferFormat() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOGL_SETUP_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).eBufferFormat) as usize - ptr as usize
			},
			4usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOGL_SETUP_PARAMS),
				"::",
				stringify!(eBufferFormat)
			)
		);
	}
	test_field_eBufferFormat();
	fn test_field_bWithDiffMap() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOGL_SETUP_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).bWithDiffMap) as usize - ptr as usize
			},
			8usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOGL_SETUP_PARAMS),
				"::",
				stringify!(bWithDiffMap)
			)
		);
	}
	test_field_bWithDiffMap();
	fn test_field_ppDiffMap() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOGL_SETUP_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).ppDiffMap) as usize - ptr as usize
			},
			16usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOGL_SETUP_PARAMS),
				"::",
				stringify!(ppDiffMap)
			)
		);
	}
	test_field_ppDiffMap();
	fn test_field_dwDiffMapScalingFactor() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOGL_SETUP_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwDiffMapScalingFactor) as usize - ptr as usize
			},
			24usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOGL_SETUP_PARAMS),
				"::",
				stringify!(dwDiffMapScalingFactor)
			)
		);
	}
	test_field_dwDiffMapScalingFactor();
	fn test_field_dwTextures() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOGL_SETUP_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwTextures) as usize - ptr as usize
			},
			28usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOGL_SETUP_PARAMS),
				"::",
				stringify!(dwTextures)
			)
		);
	}
	test_field_dwTextures();
	fn test_field_dwTexTarget() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOGL_SETUP_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwTexTarget) as usize - ptr as usize
			},
			36usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOGL_SETUP_PARAMS),
				"::",
				stringify!(dwTexTarget)
			)
		);
	}
	test_field_dwTexTarget();
	fn test_field_dwTexFormat() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOGL_SETUP_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwTexFormat) as usize - ptr as usize
			},
			40usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOGL_SETUP_PARAMS),
				"::",
				stringify!(dwTexFormat)
			)
		);
	}
	test_field_dwTexFormat();
	fn test_field_dwTexType() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOGL_SETUP_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwTexType) as usize - ptr as usize
			},
			44usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOGL_SETUP_PARAMS),
				"::",
				stringify!(dwTexType)
			)
		);
	}
	test_field_dwTexType();
	fn test_field_diffMapSize() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOGL_SETUP_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).diffMapSize) as usize - ptr as usize
			},
			48usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOGL_SETUP_PARAMS),
				"::",
				stringify!(diffMapSize)
			)
		);
	}
	test_field_diffMapSize();
}
#[doc = " Defines parameters for the ::NvFBCToGLSetUp() API call."]
pub type NVFBC_TOGL_SETUP_PARAMS = _NVFBC_TOGL_SETUP_PARAMS;
#[doc = " Defines parameters for the ::NvFBCToGLGrabFrame() API call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NVFBC_TOGL_GRAB_FRAME_PARAMS {
	#[doc = " [in] Must be set to NVFBC_TOGL_GRAB_FRAME_PARAMS_VER."]
	pub dwVersion: u32,
	#[doc = " [in] Flags defining the behavior of this frame capture."]
	pub dwFlags: u32,
	#[doc = " [out] Index of the texture storing the current frame."]
	#[doc = ""]
	#[doc = " This is an index in the NVFBC_TOGL_SETUP_PARAMS::dwTextures array."]
	pub dwTextureIndex: u32,
	#[doc = " [out] Information about the captured frame."]
	#[doc = ""]
	#[doc = " Can be NULL."]
	pub pFrameGrabInfo: *mut NVFBC_FRAME_GRAB_INFO,
	#[doc = " [in] Wait timeout in milliseconds."]
	#[doc = ""]
	#[doc = " When capturing frames with the NVFBC_TOGL_GRAB_FLAGS_NOFLAGS or"]
	#[doc = " NVFBC_TOGL_GRAB_FLAGS_NOWAIT_IF_NEW_FRAME_READY flags,"]
	#[doc = " NvFBC will wait for a new frame or mouse move until the below timer"]
	#[doc = " expires."]
	#[doc = ""]
	#[doc = " When timing out, the last captured frame will be returned.  Note that as"]
	#[doc = " long as the NVFBC_TOGL_GRAB_FLAGS_FORCE_REFRESH flag is not set,"]
	#[doc = " returning an old frame will incur no performance penalty."]
	#[doc = ""]
	#[doc = " NvFBC clients can use the return value of the grab frame operation to"]
	#[doc = " find out whether a new frame was captured, or the timer expired."]
	#[doc = ""]
	#[doc = " Note that the behavior of blocking calls is to wait for a new frame"]
	#[doc = " *after* the call has been made.  When using timeouts, it is possible"]
	#[doc = " that NvFBC will return a new frame (e.g., it has never been captured"]
	#[doc = " before) even though no new frame was generated after the grab call."]
	#[doc = ""]
	#[doc = " For the precise definition of what constitutes a new frame, see"]
	#[doc = " ::bIsNewFrame."]
	#[doc = ""]
	#[doc = " Set to 0 to disable timeouts."]
	pub dwTimeoutMs: u32,
}
#[test]
fn bindgen_test_layout__NVFBC_TOGL_GRAB_FRAME_PARAMS() {
	assert_eq!(
		::std::mem::size_of::<_NVFBC_TOGL_GRAB_FRAME_PARAMS>(),
		32usize,
		concat!("Size of: ", stringify!(_NVFBC_TOGL_GRAB_FRAME_PARAMS))
	);
	assert_eq!(
		::std::mem::align_of::<_NVFBC_TOGL_GRAB_FRAME_PARAMS>(),
		8usize,
		concat!("Alignment of ", stringify!(_NVFBC_TOGL_GRAB_FRAME_PARAMS))
	);
	fn test_field_dwVersion() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOGL_GRAB_FRAME_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwVersion) as usize - ptr as usize
			},
			0usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOGL_GRAB_FRAME_PARAMS),
				"::",
				stringify!(dwVersion)
			)
		);
	}
	test_field_dwVersion();
	fn test_field_dwFlags() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOGL_GRAB_FRAME_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwFlags) as usize - ptr as usize
			},
			4usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOGL_GRAB_FRAME_PARAMS),
				"::",
				stringify!(dwFlags)
			)
		);
	}
	test_field_dwFlags();
	fn test_field_dwTextureIndex() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOGL_GRAB_FRAME_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwTextureIndex) as usize - ptr as usize
			},
			8usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOGL_GRAB_FRAME_PARAMS),
				"::",
				stringify!(dwTextureIndex)
			)
		);
	}
	test_field_dwTextureIndex();
	fn test_field_pFrameGrabInfo() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOGL_GRAB_FRAME_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).pFrameGrabInfo) as usize - ptr as usize
			},
			16usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOGL_GRAB_FRAME_PARAMS),
				"::",
				stringify!(pFrameGrabInfo)
			)
		);
	}
	test_field_pFrameGrabInfo();
	fn test_field_dwTimeoutMs() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<_NVFBC_TOGL_GRAB_FRAME_PARAMS>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwTimeoutMs) as usize - ptr as usize
			},
			24usize,
			concat!(
				"Offset of field: ",
				stringify!(_NVFBC_TOGL_GRAB_FRAME_PARAMS),
				"::",
				stringify!(dwTimeoutMs)
			)
		);
	}
	test_field_dwTimeoutMs();
}
#[doc = " Defines parameters for the ::NvFBCToGLGrabFrame() API call."]
pub type NVFBC_TOGL_GRAB_FRAME_PARAMS = _NVFBC_TOGL_GRAB_FRAME_PARAMS;
extern "C" {
	#[doc = " Gets the last error message that got recorded for a client."]
	#[doc = ""]
	#[doc = " When NvFBC returns an error, it will save an error message that can be"]
	#[doc = " queried through this API call.  Only the last message is saved."]
	#[doc = " The message and the return code should give enough information about"]
	#[doc = " what went wrong."]
	#[doc = ""]
	#[doc = " \\param [in] sessionHandle"]
	#[doc = "   Handle to the NvFBC client."]
	#[doc = " \\return"]
	#[doc = "   A NULL terminated error message, or an empty string.  Its maximum length"]
	#[doc = "   is NVFBC_ERROR_STR_LEN."]
	pub fn NvFBCGetLastErrorStr(sessionHandle: NVFBC_SESSION_HANDLE) -> *const ::std::os::raw::c_char;
}
extern "C" {
	#[doc = " \\brief Allocates a new handle for an NvFBC client."]
	#[doc = ""]
	#[doc = " This function allocates a session handle used to identify an FBC client."]
	#[doc = ""]
	#[doc = " This function implicitly calls NvFBCBindContext()."]
	#[doc = ""]
	#[doc = " \\param [out] pSessionHandle"]
	#[doc = "   Pointer that will hold the allocated session handle."]
	#[doc = " \\param [in] pParams"]
	#[doc = "   ::NVFBC_CREATE_HANDLE_PARAMS"]
	#[doc = ""]
	#[doc = " \\return"]
	#[doc = "   ::NVFBC_SUCCESS \\n"]
	#[doc = "   ::NVFBC_ERR_INVALID_PTR \\n"]
	#[doc = "   ::NVFBC_ERR_API_VERSION \\n"]
	#[doc = "   ::NVFBC_ERR_INTERNAL \\n"]
	#[doc = "   ::NVFBC_ERR_OUT_OF_MEMORY \\n"]
	#[doc = "   ::NVFBC_ERR_MAX_CLIENTS \\n"]
	#[doc = "   ::NVFBC_ERR_X \\n"]
	#[doc = "   ::NVFBC_ERR_GLX \\n"]
	#[doc = "   ::NVFBC_ERR_GL"]
	#[doc = ""]
	pub fn NvFBCCreateHandle(
		pSessionHandle: *mut NVFBC_SESSION_HANDLE,
		pParams: *mut NVFBC_CREATE_HANDLE_PARAMS,
	) -> NVFBCSTATUS;
}
extern "C" {
	#[doc = " \\brief Destroys the handle of an NvFBC client."]
	#[doc = ""]
	#[doc = " This function uninitializes an FBC client."]
	#[doc = ""]
	#[doc = " This function implicitly calls NvFBCReleaseContext()."]
	#[doc = ""]
	#[doc = " After this fucntion returns, it is not possible to use this session handle"]
	#[doc = " for any further API call."]
	#[doc = ""]
	#[doc = " \\param [in] sessionHandle"]
	#[doc = "   FBC session handle."]
	#[doc = " \\param [in] pParams"]
	#[doc = "   ::NVFBC_DESTROY_HANDLE_PARAMS"]
	#[doc = ""]
	#[doc = " \\return"]
	#[doc = "   ::NVFBC_SUCCESS \\n"]
	#[doc = "   ::NVFBC_ERR_INVALID_HANDLE \\n"]
	#[doc = "   ::NVFBC_ERR_API_VERSION \\n"]
	#[doc = "   ::NVFBC_ERR_BAD_REQUEST \\n"]
	#[doc = "   ::NVFBC_ERR_INTERNAL \\n"]
	#[doc = "   ::NVFBC_ERR_CONTEXT \\n"]
	#[doc = "   ::NVFBC_ERR_X"]
	pub fn NvFBCDestroyHandle(
		sessionHandle: NVFBC_SESSION_HANDLE,
		pParams: *mut NVFBC_DESTROY_HANDLE_PARAMS,
	) -> NVFBCSTATUS;
}
extern "C" {
	#[doc = " \\brief Gets the current status of the display driver."]
	#[doc = ""]
	#[doc = " This function queries the display driver for various information."]
	#[doc = ""]
	#[doc = " \\param [in] sessionHandle"]
	#[doc = "   FBC session handle."]
	#[doc = " \\param [in] pParams"]
	#[doc = "   ::NVFBC_GET_STATUS_PARAMS"]
	#[doc = ""]
	#[doc = " \\return"]
	#[doc = "   ::NVFBC_SUCCESS \\n"]
	#[doc = "   ::NVFBC_ERR_INVALID_HANDLE \\n"]
	#[doc = "   ::NVFBC_ERR_API_VERSION \\n"]
	#[doc = "   ::NVFBC_ERR_INTERNAL \\n"]
	#[doc = "   ::NVFBC_ERR_X"]
	pub fn NvFBCGetStatus(sessionHandle: NVFBC_SESSION_HANDLE, pParams: *mut NVFBC_GET_STATUS_PARAMS) -> NVFBCSTATUS;
}
extern "C" {
	#[doc = " \\brief Binds the FBC context to the calling thread."]
	#[doc = ""]
	#[doc = " The NvFBC library internally relies on objects that must be bound to a"]
	#[doc = " thread.  Such objects are OpenGL contexts and CUDA contexts."]
	#[doc = ""]
	#[doc = " This function binds these objects to the calling thread."]
	#[doc = ""]
	#[doc = " The FBC context must be bound to the calling thread for most NvFBC entry"]
	#[doc = " points, otherwise ::NVFBC_ERR_CONTEXT is returned."]
	#[doc = ""]
	#[doc = " If the FBC context is already bound to a different thread,"]
	#[doc = " ::NVFBC_ERR_CONTEXT is returned.  The other thread must release the context"]
	#[doc = " first by calling the ReleaseContext() entry point."]
	#[doc = ""]
	#[doc = " If the FBC context is already bound to the current thread, this function has"]
	#[doc = " no effects."]
	#[doc = ""]
	#[doc = " \\param [in] sessionHandle"]
	#[doc = "   FBC session handle."]
	#[doc = " \\param [in] pParams"]
	#[doc = "   ::NVFBC_DESTROY_CAPTURE_SESSION_PARAMS"]
	#[doc = ""]
	#[doc = " \\return"]
	#[doc = "   ::NVFBC_SUCCESS \\n"]
	#[doc = "   ::NVFBC_ERR_INVALID_HANDLE \\n"]
	#[doc = "   ::NVFBC_ERR_API_VERSION \\n"]
	#[doc = "   ::NVFBC_ERR_BAD_REQUEST \\n"]
	#[doc = "   ::NVFBC_ERR_CONTEXT \\n"]
	#[doc = "   ::NVFBC_ERR_INTERNAL \\n"]
	#[doc = "   ::NVFBC_ERR_X"]
	pub fn NvFBCBindContext(
		sessionHandle: NVFBC_SESSION_HANDLE,
		pParams: *mut NVFBC_BIND_CONTEXT_PARAMS,
	) -> NVFBCSTATUS;
}
extern "C" {
	#[doc = " \\brief Releases the FBC context from the calling thread."]
	#[doc = ""]
	#[doc = " If the FBC context is bound to a different thread, ::NVFBC_ERR_CONTEXT is"]
	#[doc = " returned."]
	#[doc = ""]
	#[doc = " If the FBC context is already released, this functino has no effects."]
	#[doc = ""]
	#[doc = " \\param [in] sessionHandle"]
	#[doc = "   FBC session handle."]
	#[doc = " \\param [in] pParams"]
	#[doc = "   ::NVFBC_SUCCESS \\n"]
	#[doc = "   ::NVFBC_ERR_INVALID_HANDLE \\n"]
	#[doc = "   ::NVFBC_ERR_API_VERSION \\n"]
	#[doc = "   ::NVFBC_ERR_BAD_REQUEST \\n"]
	#[doc = "   ::NVFBC_ERR_CONTEXT \\n"]
	#[doc = "   ::NVFBC_ERR_INTERNAL \\n"]
	#[doc = "   ::NVFBC_ERR_X"]
	pub fn NvFBCReleaseContext(
		sessionHandle: NVFBC_SESSION_HANDLE,
		pParams: *mut NVFBC_RELEASE_CONTEXT_PARAMS,
	) -> NVFBCSTATUS;
}
extern "C" {
	#[doc = " \\brief Creates a capture session for an FBC client."]
	#[doc = ""]
	#[doc = " This function starts a capture session of the desired type (system memory,"]
	#[doc = " video memory with CUDA interop, or H.264 compressed frames in system memory)."]
	#[doc = ""]
	#[doc = " Not all types are supported on all systems.  Also, it is possible to use"]
	#[doc = " NvFBC without having the CUDA library.  In this case, requesting a capture"]
	#[doc = " session of the concerned type will return an error."]
	#[doc = ""]
	#[doc = " After this function returns, the display driver will start generating frames"]
	#[doc = " that can be captured using the corresponding API call."]
	#[doc = ""]
	#[doc = " \\param [in] sessionHandle"]
	#[doc = "   FBC session handle."]
	#[doc = " \\param [in] pParams"]
	#[doc = "   ::NVFBC_CREATE_CAPTURE_SESSION_PARAMS"]
	#[doc = ""]
	#[doc = " \\return"]
	#[doc = "   ::NVFBC_SUCCESS \\n"]
	#[doc = "   ::NVFBC_ERR_INVALID_HANDLE \\n"]
	#[doc = "   ::NVFBC_ERR_API_VERSION \\n"]
	#[doc = "   ::NVFBC_ERR_BAD_REQUEST \\n"]
	#[doc = "   ::NVFBC_ERR_CONTEXT \\n"]
	#[doc = "   ::NVFBC_ERR_INVALID_PARAM \\n"]
	#[doc = "   ::NVFBC_ERR_OUT_OF_MEMORY \\n"]
	#[doc = "   ::NVFBC_ERR_X \\n"]
	#[doc = "   ::NVFBC_ERR_GLX \\n"]
	#[doc = "   ::NVFBC_ERR_GL \\n"]
	#[doc = "   ::NVFBC_ERR_CUDA \\n"]
	#[doc = "   ::NVFBC_ERR_MUST_RECREATE \\n"]
	#[doc = "   ::NVFBC_ERR_INTERNAL"]
	pub fn NvFBCCreateCaptureSession(
		sessionHandle: NVFBC_SESSION_HANDLE,
		pParams: *mut NVFBC_CREATE_CAPTURE_SESSION_PARAMS,
	) -> NVFBCSTATUS;
}
extern "C" {
	#[doc = " \\brief Destroys a capture session for an FBC client."]
	#[doc = ""]
	#[doc = " This function stops a capture session and frees allocated objects."]
	#[doc = ""]
	#[doc = " After this function returns, it is possible to create another capture"]
	#[doc = " session using the corresponding API call."]
	#[doc = ""]
	#[doc = " \\param [in] sessionHandle"]
	#[doc = "   FBC session handle."]
	#[doc = " \\param [in] pParams"]
	#[doc = "   ::NVFBC_DESTROY_CAPTURE_SESSION_PARAMS"]
	#[doc = ""]
	#[doc = " \\return"]
	#[doc = "   ::NVFBC_SUCCESS \\n"]
	#[doc = "   ::NVFBC_ERR_INVALID_HANDLE \\n"]
	#[doc = "   ::NVFBC_ERR_API_VERSION \\n"]
	#[doc = "   ::NVFBC_ERR_BAD_REQUEST \\n"]
	#[doc = "   ::NVFBC_ERR_CONTEXT \\n"]
	#[doc = "   ::NVFBC_ERR_INTERNAL \\n"]
	#[doc = "   ::NVFBC_ERR_X"]
	pub fn NvFBCDestroyCaptureSession(
		sessionHandle: NVFBC_SESSION_HANDLE,
		pParams: *mut NVFBC_DESTROY_CAPTURE_SESSION_PARAMS,
	) -> NVFBCSTATUS;
}
extern "C" {
	#[doc = " \\brief Sets up a capture to system memory session."]
	#[doc = ""]
	#[doc = " This function configures how the capture to system memory should behave. It"]
	#[doc = " can be called anytime and several times after the capture session has been"]
	#[doc = " created.  However, it must be called at least once prior to start capturing"]
	#[doc = " frames."]
	#[doc = ""]
	#[doc = " This function allocates the buffer that will contain the captured frame."]
	#[doc = " The application does not need to free this buffer.  The size of this buffer"]
	#[doc = " is returned in the ::NVFBC_FRAME_GRAB_INFO structure."]
	#[doc = ""]
	#[doc = " \\param [in] sessionHandle"]
	#[doc = "   FBC session handle."]
	#[doc = " \\param [in] pParams"]
	#[doc = "   ::NVFBC_TOSYS_SETUP_PARAMS"]
	#[doc = ""]
	#[doc = " \\return"]
	#[doc = "   ::NVFBC_SUCCESS \\n"]
	#[doc = "   ::NVFBC_ERR_INVALID_HANDLE \\n"]
	#[doc = "   ::NVFBC_ERR_API_VERSION \\n"]
	#[doc = "   ::NVFBC_ERR_BAD_REQUEST \\n"]
	#[doc = "   ::NVFBC_ERR_INTERNAL \\n"]
	#[doc = "   ::NVFBC_ERR_CONTEXT \\n"]
	#[doc = "   ::NVFBC_ERR_UNSUPPORTED \\n"]
	#[doc = "   ::NVFBC_ERR_INVALID_PTR \\n"]
	#[doc = "   ::NVFBC_ERR_INVALID_PARAM \\n"]
	#[doc = "   ::NVFBC_ERR_OUT_OF_MEMORY \\n"]
	#[doc = "   ::NVFBC_ERR_X"]
	pub fn NvFBCToSysSetUp(sessionHandle: NVFBC_SESSION_HANDLE, pParams: *mut NVFBC_TOSYS_SETUP_PARAMS) -> NVFBCSTATUS;
}
extern "C" {
	#[doc = " \\brief Captures a frame to a buffer in system memory."]
	#[doc = ""]
	#[doc = " This function triggers a frame capture to a buffer in system memory that was"]
	#[doc = " registered with the ToSysSetUp() API call."]
	#[doc = ""]
	#[doc = " Note that it is possible that the resolution of the desktop changes while"]
	#[doc = " capturing frames. This should be transparent for the application."]
	#[doc = ""]
	#[doc = " When the resolution changes, the capture session is recreated using the same"]
	#[doc = " parameters, and necessary buffers are re-allocated. The frame counter is not"]
	#[doc = " reset."]
	#[doc = ""]
	#[doc = " An application can detect that the resolution changed by comparing the"]
	#[doc = " dwByteSize member of the ::NVFBC_FRAME_GRAB_INFO against a previous"]
	#[doc = " frame and/or dwWidth and dwHeight."]
	#[doc = ""]
	#[doc = " During a change of resolution the capture is paused even in asynchronous"]
	#[doc = " mode."]
	#[doc = ""]
	#[doc = " \\param [in] sessionHandle"]
	#[doc = "   FBC session handle."]
	#[doc = " \\param [in] pParams"]
	#[doc = "   ::NVFBC_TOSYS_GRAB_FRAME_PARAMS"]
	#[doc = ""]
	#[doc = " \\return"]
	#[doc = "   ::NVFBC_SUCCESS \\n"]
	#[doc = "   ::NVFBC_ERR_INVALID_HANDLE \\n"]
	#[doc = "   ::NVFBC_ERR_API_VERSION \\n"]
	#[doc = "   ::NVFBC_ERR_BAD_REQUEST \\n"]
	#[doc = "   ::NVFBC_ERR_CONTEXT \\n"]
	#[doc = "   ::NVFBC_ERR_INVALID_PTR \\n"]
	#[doc = "   ::NVFBC_ERR_INTERNAL \\n"]
	#[doc = "   ::NVFBC_ERR_X \\n"]
	#[doc = "   ::NVFBC_ERR_MUST_RECREATE \\n"]
	#[doc = "   \\see NvFBCCreateCaptureSession \\n"]
	#[doc = "   \\see NvFBCToSysSetUp"]
	pub fn NvFBCToSysGrabFrame(
		sessionHandle: NVFBC_SESSION_HANDLE,
		pParams: *mut NVFBC_TOSYS_GRAB_FRAME_PARAMS,
	) -> NVFBCSTATUS;
}
extern "C" {
	#[doc = " \\brief Sets up a capture to video memory session."]
	#[doc = ""]
	#[doc = " This function configures how the capture to video memory with CUDA interop"]
	#[doc = " should behave.  It can be called anytime and several times after the capture"]
	#[doc = " session has been created.  However, it must be called at least once prior"]
	#[doc = " to start capturing frames."]
	#[doc = ""]
	#[doc = " \\param [in] sessionHandle"]
	#[doc = "   FBC session handle."]
	#[doc = ""]
	#[doc = " \\param [in] pParams"]
	#[doc = "   ::NVFBC_TOCUDA_SETUP_PARAMS"]
	#[doc = ""]
	#[doc = " \\return"]
	#[doc = "   ::NVFBC_SUCCESS \\n"]
	#[doc = "   ::NVFBC_ERR_INVALID_HANDLE \\n"]
	#[doc = "   ::NVFBC_ERR_API_VERSION \\n"]
	#[doc = "   ::NVFBC_ERR_BAD_REQUEST \\n"]
	#[doc = "   ::NVFBC_ERR_INTERNAL \\n"]
	#[doc = "   ::NVFBC_ERR_CONTEXT \\n"]
	#[doc = "   ::NVFBC_ERR_UNSUPPORTED \\n"]
	#[doc = "   ::NVFBC_ERR_GL \\n"]
	#[doc = "   ::NVFBC_ERR_X"]
	pub fn NvFBCToCudaSetUp(
		sessionHandle: NVFBC_SESSION_HANDLE,
		pParams: *mut NVFBC_TOCUDA_SETUP_PARAMS,
	) -> NVFBCSTATUS;
}
extern "C" {
	#[doc = " \\brief Captures a frame to a CUDA device in video memory."]
	#[doc = ""]
	#[doc = " This function triggers a frame capture to a CUDA device in video memory."]
	#[doc = ""]
	#[doc = " Note about changes of resolution: \\see NvFBCToSysGrabFrame"]
	#[doc = ""]
	#[doc = " \\param [in] sessionHandle"]
	#[doc = "   FBC session handle."]
	#[doc = ""]
	#[doc = " \\param [in] pParams"]
	#[doc = "   ::NVFBC_TOCUDA_GRAB_FRAME_PARAMS"]
	#[doc = ""]
	#[doc = " \\return"]
	#[doc = "   ::NVFBC_SUCCESS \\n"]
	#[doc = "   ::NVFBC_ERR_INVALID_HANDLE \\n"]
	#[doc = "   ::NVFBC_ERR_API_VERSION \\n"]
	#[doc = "   ::NVFBC_ERR_BAD_REQUEST \\n"]
	#[doc = "   ::NVFBC_ERR_CONTEXT \\n"]
	#[doc = "   ::NVFBC_ERR_INVALID_PTR \\n"]
	#[doc = "   ::NVFBC_ERR_CUDA \\n"]
	#[doc = "   ::NVFBC_ERR_INTERNAL \\n"]
	#[doc = "   ::NVFBC_ERR_X \\n"]
	#[doc = "   ::NVFBC_ERR_MUST_RECREATE \\n"]
	#[doc = "   \\see NvFBCCreateCaptureSession \\n"]
	#[doc = "   \\see NvFBCToCudaSetUp"]
	pub fn NvFBCToCudaGrabFrame(
		sessionHandle: NVFBC_SESSION_HANDLE,
		pParams: *mut NVFBC_TOCUDA_GRAB_FRAME_PARAMS,
	) -> NVFBCSTATUS;
}
extern "C" {
	#[doc = " \\brief Sets up a capture to OpenGL buffer in video memory session."]
	#[doc = ""]
	#[doc = " This function configures how the capture to video memory should behave."]
	#[doc = " It can be called anytime and several times after the capture session has been"]
	#[doc = " created.  However, it must be called at least once prior to start capturing"]
	#[doc = " frames."]
	#[doc = ""]
	#[doc = " \\param [in] sessionHandle"]
	#[doc = "   FBC session handle."]
	#[doc = ""]
	#[doc = " \\param [in] pParams"]
	#[doc = "   ::NVFBC_TOGL_SETUP_PARAMS"]
	#[doc = ""]
	#[doc = " \\return"]
	#[doc = "   ::NVFBC_SUCCESS \\n"]
	#[doc = "   ::NVFBC_ERR_INVALID_HANDLE \\n"]
	#[doc = "   ::NVFBC_ERR_API_VERSION \\n"]
	#[doc = "   ::NVFBC_ERR_BAD_REQUEST \\n"]
	#[doc = "   ::NVFBC_ERR_INTERNAL \\n"]
	#[doc = "   ::NVFBC_ERR_CONTEXT \\n"]
	#[doc = "   ::NVFBC_ERR_UNSUPPORTED \\n"]
	#[doc = "   ::NVFBC_ERR_GL \\n"]
	#[doc = "   ::NVFBC_ERR_X"]
	pub fn NvFBCToGLSetUp(sessionHandle: NVFBC_SESSION_HANDLE, pParams: *mut NVFBC_TOGL_SETUP_PARAMS) -> NVFBCSTATUS;
}
extern "C" {
	#[doc = " \\brief Captures a frame to an OpenGL buffer in video memory."]
	#[doc = ""]
	#[doc = " This function triggers a frame capture to a selected resource in video memory."]
	#[doc = ""]
	#[doc = " Note about changes of resolution: \\see NvFBCToSysGrabFrame"]
	#[doc = ""]
	#[doc = " \\param [in] sessionHandle"]
	#[doc = "   FBC session handle."]
	#[doc = ""]
	#[doc = " \\param [in] pParams"]
	#[doc = "   ::NVFBC_TOGL_GRAB_FRAME_PARAMS"]
	#[doc = ""]
	#[doc = " \\return"]
	#[doc = "   ::NVFBC_SUCCESS \\n"]
	#[doc = "   ::NVFBC_ERR_INVALID_HANDLE \\n"]
	#[doc = "   ::NVFBC_ERR_API_VERSION \\n"]
	#[doc = "   ::NVFBC_ERR_BAD_REQUEST \\n"]
	#[doc = "   ::NVFBC_ERR_CONTEXT \\n"]
	#[doc = "   ::NVFBC_ERR_INVALID_PTR \\n"]
	#[doc = "   ::NVFBC_ERR_INTERNAL \\n"]
	#[doc = "   ::NVFBC_ERR_X \\n"]
	#[doc = "   ::NVFBC_ERR_MUST_RECREATE \\n"]
	#[doc = "   \\see NvFBCCreateCaptureSession \\n"]
	#[doc = "   \\see NvFBCToCudaSetUp"]
	pub fn NvFBCToGLGrabFrame(
		sessionHandle: NVFBC_SESSION_HANDLE,
		pParams: *mut NVFBC_TOGL_GRAB_FRAME_PARAMS,
	) -> NVFBCSTATUS;
}
#[doc = " \\cond FBC_PFN"]
#[doc = ""]
#[doc = " Defines API function pointers"]
pub type PNVFBCGETLASTERRORSTR =
	::std::option::Option<unsafe extern "C" fn(sessionHandle: NVFBC_SESSION_HANDLE) -> *const ::std::os::raw::c_char>;
pub type PNVFBCCREATEHANDLE = ::std::option::Option<
	unsafe extern "C" fn(
		pSessionHandle: *mut NVFBC_SESSION_HANDLE,
		pParams: *mut NVFBC_CREATE_HANDLE_PARAMS,
	) -> NVFBCSTATUS,
>;
pub type PNVFBCDESTROYHANDLE = ::std::option::Option<
	unsafe extern "C" fn(sessionHandle: NVFBC_SESSION_HANDLE, pParams: *mut NVFBC_DESTROY_HANDLE_PARAMS) -> NVFBCSTATUS,
>;
pub type PNVFBCBINDCONTEXT = ::std::option::Option<
	unsafe extern "C" fn(sessionHandle: NVFBC_SESSION_HANDLE, pParams: *mut NVFBC_BIND_CONTEXT_PARAMS) -> NVFBCSTATUS,
>;
pub type PNVFBCRELEASECONTEXT = ::std::option::Option<
	unsafe extern "C" fn(
		sessionHandle: NVFBC_SESSION_HANDLE,
		pParams: *mut NVFBC_RELEASE_CONTEXT_PARAMS,
	) -> NVFBCSTATUS,
>;
pub type PNVFBCGETSTATUS = ::std::option::Option<
	unsafe extern "C" fn(sessionHandle: NVFBC_SESSION_HANDLE, pParams: *mut NVFBC_GET_STATUS_PARAMS) -> NVFBCSTATUS,
>;
pub type PNVFBCCREATECAPTURESESSION = ::std::option::Option<
	unsafe extern "C" fn(
		sessionHandle: NVFBC_SESSION_HANDLE,
		pParams: *mut NVFBC_CREATE_CAPTURE_SESSION_PARAMS,
	) -> NVFBCSTATUS,
>;
pub type PNVFBCDESTROYCAPTURESESSION = ::std::option::Option<
	unsafe extern "C" fn(
		sessionHandle: NVFBC_SESSION_HANDLE,
		pParams: *mut NVFBC_DESTROY_CAPTURE_SESSION_PARAMS,
	) -> NVFBCSTATUS,
>;
pub type PNVFBCTOSYSSETUP = ::std::option::Option<
	unsafe extern "C" fn(sessionHandle: NVFBC_SESSION_HANDLE, pParams: *mut NVFBC_TOSYS_SETUP_PARAMS) -> NVFBCSTATUS,
>;
pub type PNVFBCTOSYSGRABFRAME = ::std::option::Option<
	unsafe extern "C" fn(
		sessionHandle: NVFBC_SESSION_HANDLE,
		pParams: *mut NVFBC_TOSYS_GRAB_FRAME_PARAMS,
	) -> NVFBCSTATUS,
>;
pub type PNVFBCTOCUDASETUP = ::std::option::Option<
	unsafe extern "C" fn(sessionHandle: NVFBC_SESSION_HANDLE, pParams: *mut NVFBC_TOCUDA_SETUP_PARAMS) -> NVFBCSTATUS,
>;
pub type PNVFBCTOCUDAGRABFRAME = ::std::option::Option<
	unsafe extern "C" fn(
		sessionHandle: NVFBC_SESSION_HANDLE,
		pParams: *mut NVFBC_TOCUDA_GRAB_FRAME_PARAMS,
	) -> NVFBCSTATUS,
>;
pub type PNVFBCTOGLSETUP = ::std::option::Option<
	unsafe extern "C" fn(sessionHandle: NVFBC_SESSION_HANDLE, pParams: *mut NVFBC_TOGL_SETUP_PARAMS) -> NVFBCSTATUS,
>;
pub type PNVFBCTOGLGRABFRAME = ::std::option::Option<
	unsafe extern "C" fn(
		sessionHandle: NVFBC_SESSION_HANDLE,
		pParams: *mut NVFBC_TOGL_GRAB_FRAME_PARAMS,
	) -> NVFBCSTATUS,
>;
#[doc = " \\ingroup FBC_STRUCT"]
#[doc = ""]
#[doc = " Structure populated with API function pointers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NVFBC_API_FUNCTION_LIST {
	#[doc = "!< [in] Must be set to NVFBC_VERSION."]
	pub dwVersion: u32,
	#[doc = "!< [out] Pointer to ::NvFBCGetLastErrorStr()."]
	pub nvFBCGetLastErrorStr: PNVFBCGETLASTERRORSTR,
	#[doc = "!< [out] Pointer to ::NvFBCCreateHandle()."]
	pub nvFBCCreateHandle: PNVFBCCREATEHANDLE,
	#[doc = "!< [out] Pointer to ::NvFBCDestroyHandle()."]
	pub nvFBCDestroyHandle: PNVFBCDESTROYHANDLE,
	#[doc = "!< [out] Pointer to ::NvFBCGetStatus()."]
	pub nvFBCGetStatus: PNVFBCGETSTATUS,
	#[doc = "!< [out] Pointer to ::NvFBCCreateCaptureSession()."]
	pub nvFBCCreateCaptureSession: PNVFBCCREATECAPTURESESSION,
	#[doc = "!< [out] Pointer to ::NvFBCDestroyCaptureSession()."]
	pub nvFBCDestroyCaptureSession: PNVFBCDESTROYCAPTURESESSION,
	#[doc = "!< [out] Pointer to ::NvFBCToSysSetUp()."]
	pub nvFBCToSysSetUp: PNVFBCTOSYSSETUP,
	#[doc = "!< [out] Pointer to ::NvFBCToSysGrabFrame()."]
	pub nvFBCToSysGrabFrame: PNVFBCTOSYSGRABFRAME,
	#[doc = "!< [out] Pointer to ::NvFBCToCudaSetUp()."]
	pub nvFBCToCudaSetUp: PNVFBCTOCUDASETUP,
	#[doc = "!< [out] Pointer to ::NvFBCToCudaGrabFrame()."]
	pub nvFBCToCudaGrabFrame: PNVFBCTOCUDAGRABFRAME,
	#[doc = "!< [out] Retired. Do not use."]
	pub pad1: *mut ::std::os::raw::c_void,
	#[doc = "!< [out] Retired. Do not use."]
	pub pad2: *mut ::std::os::raw::c_void,
	#[doc = "!< [out] Retired. Do not use."]
	pub pad3: *mut ::std::os::raw::c_void,
	#[doc = "!< [out] Pointer to ::NvFBCBindContext()."]
	pub nvFBCBindContext: PNVFBCBINDCONTEXT,
	#[doc = "!< [out] Pointer to ::NvFBCReleaseContext()."]
	pub nvFBCReleaseContext: PNVFBCRELEASECONTEXT,
	#[doc = "!< [out] Retired. Do not use."]
	pub pad4: *mut ::std::os::raw::c_void,
	#[doc = "!< [out] Retired. Do not use."]
	pub pad5: *mut ::std::os::raw::c_void,
	#[doc = "!< [out] Retired. Do not use."]
	pub pad6: *mut ::std::os::raw::c_void,
	#[doc = "!< [out] Retired. Do not use."]
	pub pad7: *mut ::std::os::raw::c_void,
	#[doc = "!< [out] Pointer to ::nvFBCToGLSetup()."]
	pub nvFBCToGLSetUp: PNVFBCTOGLSETUP,
	#[doc = "!< [out] Pointer to ::nvFBCToGLGrabFrame()."]
	pub nvFBCToGLGrabFrame: PNVFBCTOGLGRABFRAME,
}
#[test]
fn bindgen_test_layout_NVFBC_API_FUNCTION_LIST() {
	assert_eq!(
		::std::mem::size_of::<NVFBC_API_FUNCTION_LIST>(),
		176usize,
		concat!("Size of: ", stringify!(NVFBC_API_FUNCTION_LIST))
	);
	assert_eq!(
		::std::mem::align_of::<NVFBC_API_FUNCTION_LIST>(),
		8usize,
		concat!("Alignment of ", stringify!(NVFBC_API_FUNCTION_LIST))
	);
	fn test_field_dwVersion() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<NVFBC_API_FUNCTION_LIST>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).dwVersion) as usize - ptr as usize
			},
			0usize,
			concat!(
				"Offset of field: ",
				stringify!(NVFBC_API_FUNCTION_LIST),
				"::",
				stringify!(dwVersion)
			)
		);
	}
	test_field_dwVersion();
	fn test_field_nvFBCGetLastErrorStr() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<NVFBC_API_FUNCTION_LIST>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).nvFBCGetLastErrorStr) as usize - ptr as usize
			},
			8usize,
			concat!(
				"Offset of field: ",
				stringify!(NVFBC_API_FUNCTION_LIST),
				"::",
				stringify!(nvFBCGetLastErrorStr)
			)
		);
	}
	test_field_nvFBCGetLastErrorStr();
	fn test_field_nvFBCCreateHandle() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<NVFBC_API_FUNCTION_LIST>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).nvFBCCreateHandle) as usize - ptr as usize
			},
			16usize,
			concat!(
				"Offset of field: ",
				stringify!(NVFBC_API_FUNCTION_LIST),
				"::",
				stringify!(nvFBCCreateHandle)
			)
		);
	}
	test_field_nvFBCCreateHandle();
	fn test_field_nvFBCDestroyHandle() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<NVFBC_API_FUNCTION_LIST>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).nvFBCDestroyHandle) as usize - ptr as usize
			},
			24usize,
			concat!(
				"Offset of field: ",
				stringify!(NVFBC_API_FUNCTION_LIST),
				"::",
				stringify!(nvFBCDestroyHandle)
			)
		);
	}
	test_field_nvFBCDestroyHandle();
	fn test_field_nvFBCGetStatus() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<NVFBC_API_FUNCTION_LIST>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).nvFBCGetStatus) as usize - ptr as usize
			},
			32usize,
			concat!(
				"Offset of field: ",
				stringify!(NVFBC_API_FUNCTION_LIST),
				"::",
				stringify!(nvFBCGetStatus)
			)
		);
	}
	test_field_nvFBCGetStatus();
	fn test_field_nvFBCCreateCaptureSession() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<NVFBC_API_FUNCTION_LIST>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).nvFBCCreateCaptureSession) as usize - ptr as usize
			},
			40usize,
			concat!(
				"Offset of field: ",
				stringify!(NVFBC_API_FUNCTION_LIST),
				"::",
				stringify!(nvFBCCreateCaptureSession)
			)
		);
	}
	test_field_nvFBCCreateCaptureSession();
	fn test_field_nvFBCDestroyCaptureSession() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<NVFBC_API_FUNCTION_LIST>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).nvFBCDestroyCaptureSession) as usize - ptr as usize
			},
			48usize,
			concat!(
				"Offset of field: ",
				stringify!(NVFBC_API_FUNCTION_LIST),
				"::",
				stringify!(nvFBCDestroyCaptureSession)
			)
		);
	}
	test_field_nvFBCDestroyCaptureSession();
	fn test_field_nvFBCToSysSetUp() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<NVFBC_API_FUNCTION_LIST>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).nvFBCToSysSetUp) as usize - ptr as usize
			},
			56usize,
			concat!(
				"Offset of field: ",
				stringify!(NVFBC_API_FUNCTION_LIST),
				"::",
				stringify!(nvFBCToSysSetUp)
			)
		);
	}
	test_field_nvFBCToSysSetUp();
	fn test_field_nvFBCToSysGrabFrame() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<NVFBC_API_FUNCTION_LIST>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).nvFBCToSysGrabFrame) as usize - ptr as usize
			},
			64usize,
			concat!(
				"Offset of field: ",
				stringify!(NVFBC_API_FUNCTION_LIST),
				"::",
				stringify!(nvFBCToSysGrabFrame)
			)
		);
	}
	test_field_nvFBCToSysGrabFrame();
	fn test_field_nvFBCToCudaSetUp() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<NVFBC_API_FUNCTION_LIST>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).nvFBCToCudaSetUp) as usize - ptr as usize
			},
			72usize,
			concat!(
				"Offset of field: ",
				stringify!(NVFBC_API_FUNCTION_LIST),
				"::",
				stringify!(nvFBCToCudaSetUp)
			)
		);
	}
	test_field_nvFBCToCudaSetUp();
	fn test_field_nvFBCToCudaGrabFrame() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<NVFBC_API_FUNCTION_LIST>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).nvFBCToCudaGrabFrame) as usize - ptr as usize
			},
			80usize,
			concat!(
				"Offset of field: ",
				stringify!(NVFBC_API_FUNCTION_LIST),
				"::",
				stringify!(nvFBCToCudaGrabFrame)
			)
		);
	}
	test_field_nvFBCToCudaGrabFrame();
	fn test_field_pad1() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<NVFBC_API_FUNCTION_LIST>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).pad1) as usize - ptr as usize
			},
			88usize,
			concat!(
				"Offset of field: ",
				stringify!(NVFBC_API_FUNCTION_LIST),
				"::",
				stringify!(pad1)
			)
		);
	}
	test_field_pad1();
	fn test_field_pad2() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<NVFBC_API_FUNCTION_LIST>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).pad2) as usize - ptr as usize
			},
			96usize,
			concat!(
				"Offset of field: ",
				stringify!(NVFBC_API_FUNCTION_LIST),
				"::",
				stringify!(pad2)
			)
		);
	}
	test_field_pad2();
	fn test_field_pad3() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<NVFBC_API_FUNCTION_LIST>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).pad3) as usize - ptr as usize
			},
			104usize,
			concat!(
				"Offset of field: ",
				stringify!(NVFBC_API_FUNCTION_LIST),
				"::",
				stringify!(pad3)
			)
		);
	}
	test_field_pad3();
	fn test_field_nvFBCBindContext() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<NVFBC_API_FUNCTION_LIST>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).nvFBCBindContext) as usize - ptr as usize
			},
			112usize,
			concat!(
				"Offset of field: ",
				stringify!(NVFBC_API_FUNCTION_LIST),
				"::",
				stringify!(nvFBCBindContext)
			)
		);
	}
	test_field_nvFBCBindContext();
	fn test_field_nvFBCReleaseContext() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<NVFBC_API_FUNCTION_LIST>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).nvFBCReleaseContext) as usize - ptr as usize
			},
			120usize,
			concat!(
				"Offset of field: ",
				stringify!(NVFBC_API_FUNCTION_LIST),
				"::",
				stringify!(nvFBCReleaseContext)
			)
		);
	}
	test_field_nvFBCReleaseContext();
	fn test_field_pad4() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<NVFBC_API_FUNCTION_LIST>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).pad4) as usize - ptr as usize
			},
			128usize,
			concat!(
				"Offset of field: ",
				stringify!(NVFBC_API_FUNCTION_LIST),
				"::",
				stringify!(pad4)
			)
		);
	}
	test_field_pad4();
	fn test_field_pad5() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<NVFBC_API_FUNCTION_LIST>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).pad5) as usize - ptr as usize
			},
			136usize,
			concat!(
				"Offset of field: ",
				stringify!(NVFBC_API_FUNCTION_LIST),
				"::",
				stringify!(pad5)
			)
		);
	}
	test_field_pad5();
	fn test_field_pad6() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<NVFBC_API_FUNCTION_LIST>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).pad6) as usize - ptr as usize
			},
			144usize,
			concat!(
				"Offset of field: ",
				stringify!(NVFBC_API_FUNCTION_LIST),
				"::",
				stringify!(pad6)
			)
		);
	}
	test_field_pad6();
	fn test_field_pad7() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<NVFBC_API_FUNCTION_LIST>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).pad7) as usize - ptr as usize
			},
			152usize,
			concat!(
				"Offset of field: ",
				stringify!(NVFBC_API_FUNCTION_LIST),
				"::",
				stringify!(pad7)
			)
		);
	}
	test_field_pad7();
	fn test_field_nvFBCToGLSetUp() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<NVFBC_API_FUNCTION_LIST>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).nvFBCToGLSetUp) as usize - ptr as usize
			},
			160usize,
			concat!(
				"Offset of field: ",
				stringify!(NVFBC_API_FUNCTION_LIST),
				"::",
				stringify!(nvFBCToGLSetUp)
			)
		);
	}
	test_field_nvFBCToGLSetUp();
	fn test_field_nvFBCToGLGrabFrame() {
		assert_eq!(
			unsafe {
				let uninit = ::std::mem::MaybeUninit::<NVFBC_API_FUNCTION_LIST>::uninit();
				let ptr = uninit.as_ptr();
				::std::ptr::addr_of!((*ptr).nvFBCToGLGrabFrame) as usize - ptr as usize
			},
			168usize,
			concat!(
				"Offset of field: ",
				stringify!(NVFBC_API_FUNCTION_LIST),
				"::",
				stringify!(nvFBCToGLGrabFrame)
			)
		);
	}
	test_field_nvFBCToGLGrabFrame();
}
extern "C" {
	#[doc = " \\ingroup FBC_FUNC"]
	#[doc = ""]
	#[doc = " \\brief Entry Points to the NvFBC interface."]
	#[doc = ""]
	#[doc = " Creates an instance of the NvFBC interface, and populates the"]
	#[doc = " pFunctionList with function pointers to the API routines implemented by"]
	#[doc = " the NvFBC interface."]
	#[doc = ""]
	#[doc = " \\param [out] pFunctionList"]
	#[doc = ""]
	#[doc = " \\return"]
	#[doc = "   ::NVFBC_SUCCESS \\n"]
	#[doc = "   ::NVFBC_ERR_INVALID_PTR \\n"]
	#[doc = "   ::NVFBC_ERR_API_VERSION"]
	pub fn NvFBCCreateInstance(pFunctionList: *mut NVFBC_API_FUNCTION_LIST) -> NVFBCSTATUS;
}
#[doc = " \\ingroup FBC_FUNC"]
#[doc = ""]
#[doc = " Defines function pointer for the ::NvFBCCreateInstance() API call."]
pub type PNVFBCCREATEINSTANCE =
	::std::option::Option<unsafe extern "C" fn(pFunctionList: *mut NVFBC_API_FUNCTION_LIST) -> NVFBCSTATUS>;
